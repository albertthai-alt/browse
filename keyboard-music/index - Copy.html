<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Keyboard Music</title>
<link rel="icon" href='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="32" fill="%23fff3e6"/><path d="M44 10v28.5c0 4.418-5.373 8-12 8s-12-3.582-12-8 5.373-8 12-8c2.21 0 4.245.43 6 .118V10h6z" fill="%23ff7a00"/></svg>' />
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; display:flex; flex-direction:column; align-items:center; padding:24px; background: #faf7f3; color:#222; }
  h1 { width:100%; max-width:820px; box-sizing:border-box; margin:0 auto 8px; text-align:left; }
  .ver { display:inline-block; margin-left:8px; font-size:12px; color:#666; border:1px solid #ddd; padding:2px 6px; border-radius:999px; background:#fff; }
  p { margin-top:0; color:#444; }
  .keyboard { width:100%; max-width:820px; box-sizing:border-box; display:flex; flex-direction:column; gap:8px; margin:18px auto 0;
    /* Responsive sizing based on container width (not viewport) */
    --cols: 10; /* longest row */
    --gap: 6px; /* horizontal gap */
    --keyRaw: calc((100% - (var(--cols) - 1)*var(--gap)) / var(--cols));
    --key: min(52px, var(--keyRaw));
  }
  .row { display:flex; gap: var(--gap); justify-content: flex-start; }
  /* Stagger rows using flex spacer to retain centering */
  .row.r2::before { content: ""; display:block; width: calc(var(--key)/2 - var(--gap)/2); flex: 0 0 auto; }
  .row.r3::before { content: ""; display:block; width: var(--key); flex: 0 0 auto; }
  /* Trailing spacer to make each row total width equal to full columns, avoiding right drift */
  .row::after { content: ""; display:block; flex: 0 0 auto; width: calc((var(--cols) - var(--len, 0)) * (var(--key) + var(--gap)) - var(--gap)); }
  .key { width: clamp(34px, var(--key), 52px); height: clamp(34px, var(--key), 52px); display:flex; flex-direction:column; align-items:center; justify-content:center; background: linear-gradient(180deg,#fff 0%,#f0efe8 100%); border:1px solid #ddd; border-radius:8px; box-shadow: 0 6px 18px rgba(30,30,30,0.06); cursor:pointer; user-select:none; }
  .key .k { font-weight:600; }
  .key .n { font-size:11px; color:#666; margin-top:2px; }
  .key:active { transform: translateY(2px) scale(.995); box-shadow:none; }
  .key.active { outline:2px solid #0a66c2; outline-offset:-2px; }
  .key.unavailable { opacity: .45; filter: grayscale(25%); cursor: default; }
  .controls { width:100%; max-width:820px; box-sizing:border-box; margin-top:18px; margin-left:auto; margin-right:auto; }
  label { margin-right:8px; }
  .song { width:100%; max-width:820px; box-sizing:border-box; margin-top:18px; margin-left:auto; margin-right:auto; line-height: 2; }
  .song.scrollable { max-height: 50vh; overflow-y: auto; }
  .token { display:inline-block; padding:2px 4px; border-radius:6px; margin:2px 3px; background:#fff; border:1px solid #eee; }
  .token .hints { display:block; font-size:10px; color:#777; margin-top:1px; }
  .token.current { outline:2px solid #0a66c2; outline-offset:1px; background:#eef5ff; }
  .token.done { background:#e9f9ee; border-color:#bdebd0; }
  .token .doneStep { color:#3a8f5d; }
  .song-controls { margin-top:10px; }
  .key.guide { outline:2px dashed #ff7a00; outline-offset:-2px; }
  .key.guide-sharp { outline:3px solid #d61f1f; outline-offset:-2px; }
  .song-controls textarea { display:block; width:100%; max-width:820px; height:96px; margin-top:8px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; padding:8px; }
  /* Paste modal */
  .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.35); display:flex; align-items:center; justify-content:center; z-index:1000; }
  .modal { width: min(820px, 94vw); background:#fff; border-radius:10px; box-shadow: 0 20px 60px rgba(0,0,0,0.25); padding:16px; }
  .modal h3 { margin:0 0 8px 0; }
  .modal textarea { width:100%; height:180px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; padding:8px; }
  .modal .actions { display:flex; justify-content:flex-end; gap:8px; margin-top:10px; }
  .token.editing { outline:2px solid #d97706; outline-offset:1px; }
  @media (max-width: 420px) {
    body { padding: 16px; }
  }
  .composer-staff { width:100%; max-width:820px; box-sizing:border-box; margin:16px auto 0; }
  .composer-staff .staff { width:100%; height:auto; display:block; background:#fff; border:1px solid #e8e8e8; border-radius:10px; }
  .composer-staff .staff-line { stroke:#222; stroke-width:1.2; }
  .composer-staff .barline { stroke:#444; stroke-width:1.5; }
  .composer-staff .notehead { fill:#111; }
  .composer-staff .ledger { stroke:#222; stroke-width:1.1; }
  .composer-staff .note { cursor:pointer; }
  .composer-staff .note-label { font: 14px/1.2 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; fill:#333; }
</style>
</head>
<body>
<h1>Keyboard Music <span class="ver">v2.0</span></h1>
<div class="keyboard" id="keyboard"></div>
<div class="controls">
  <label>Nhạc cụ:
    <select id="instrumentSelect">
      <option value="piano" selected>Piano</option>
      <option value="tank-drum">Tank Drum</option>
      <option value="sao">Sáo</option>
      <option value="marimba">Marimba</option>
      <option value="handpan">Handpan</option>
      <option value="dan-da">Đàn đá</option>
      <option value="dan-bau">Đàn bầu</option>
    </select>
  </label>
  <label><input type="checkbox" id="toggleSolfege"> Hiển thị do re mi</label>
  <label style="margin-left:8px;"><input type="checkbox" id="toggleSongMode"> Chơi theo bài hát</label>
  <label style="margin-left:8px;"><input type="checkbox" id="toggleComposer"> Soạn nhạc</label>
</div>

<div class="song-controls">
  <label>Tải bài hát (.txt): <input type="file" id="songFile" accept=".txt" /></label>
  <button id="loadSongBtn">Tải & Hiển thị</button>
  <button id="resetSongBtn">Reset bài</button>
  <label><input type="checkbox" id="toggleShowNotes" checked> Hiển thị nốt nhạc</label>
  <label><input type="checkbox" id="toggleHighlightKeys" checked> Highlight bàn phím</label>
  <button id="pasteSongBtn">Dán & Hiển thị</button>
  <div class="composer-controls" id="composerControls" style="margin-top:8px; display:none;">
    <span id="composerStatus">Chọn một chữ để thêm nốt...</span>
    <button id="composerClearBtn" style="margin-left:8px;">Xóa nốt của chữ</button>
    <input id="composerFileName" placeholder="tên file (vd: bai-hat.txt)" style="margin-left:8px; width:220px;" />
    <button id="composerSaveBtn" style="margin-left:8px;">Lưu bài hát (.txt)</button>
  </div>
</div>
<div id="composerStaff" class="composer-staff" style="display:none;">
  <svg id="composerStaffSvg" class="staff" viewBox="0 0 1600 220" preserveAspectRatio="xMidYMid meet"></svg>
  </div>

<div class="song" id="songArea"></div>

<!-- Paste modal -->
<div id="pasteModal" class="modal-backdrop" style="display:none;">
  <div class="modal">
    <h3>Dán bài hát</h3>
    <p style="margin-top:0;color:#666;font-size:13px;">Dán nội dung theo định dạng: <code>word{C4}</code> hoặc chỉ lời không có nốt.</p>
    <textarea id="songPasteModal" placeholder="hap{C4}py{C4} ..."></textarea>
    <div class="actions">
      <button id="pasteCancel">Hủy</button>
      <button id="pasteApply">Hiển thị</button>
    </div>
  </div>
  </div>

<script src="./keymap.js"></script>
<script>
// Instruments: add Piano (Tone.js based)
const instruments = {
  'piano': {
    label: 'Piano',
    synth: 'tone-piano',
    pathPrefix: '',
    notes: [] // availability not restricted
  },
  'tank-drum': {
    label: 'Tank Drum',
    synth: 'percussive',
    pathPrefix: 'tank drum/',
    notes: []
  },
  'sao': {
    label: 'Sáo',
    synth: 'flute',
    pathPrefix: 'sao/',
    // Use a bit higher register for sáo
    notes: []
  },
  'handpan': {
    label: 'Handpan',
    synth: 'handpan',
    pathPrefix: 'handpan/',
    notes: []
  },
  'marimba': {
    label: 'Marimba',
    synth: 'marimba',
    pathPrefix: '',
    notes: []
  },
  'dan-da': {
    label: 'Đàn đá (Lithophone)',
    synth: 'lithophone',
    pathPrefix: 'dan da/',
    notes: []
  },
  'dan-bau': {
    label: 'Đàn bầu',
    synth: 'danbau',
    pathPrefix: '',
    notes: []
  }
};
let currentInstrument = 'piano';

// Default keymap used when running from file:// or when fetching keymap.json fails
const DEFAULT_KEYMAP = {
  'tank-drum': {
    q:'C3', w:'D3', e:'E3', r:'F3', t:'G3', y:'A3', u:'B3',
    i:'C4', o:'D4', p:'E4', a:'F4', s:'G4', d:'A4', f:'B4',
    g:'C5', h:'D5', j:'E5', k:'F5', l:'G5',
    z:'A5', x:'C6', c:'D6', v:'E6', b:'F6', n:'G6', m:'A6', ',':'B6'
  },
  'marimba': {
    q:'C3', w:'D3', e:'E3', r:'F3', t:'G3', y:'A3', u:'B3',
    i:'C4', o:'D4', p:'E4', a:'F4', s:'G4', d:'A4', f:'B4',
    g:'C5', h:'D5', j:'E5', k:'F5', l:'G5',
    z:'A5', x:'C6', c:'D6', v:'E6', b:'F6', n:'G6', m:'A6', ',':'B6'
  },
  'sao': {
    q:'C3', w:'D3', e:'E3', r:'F3', t:'G3', y:'A3', u:'B3',
    i:'C4', o:'D4', p:'E4', a:'F4', s:'G4', d:'A4', f:'B4',
    g:'C5', h:'D5', j:'E5', k:'F5', l:'G5',
    z:'A5', x:'C6', c:'D6', v:'E6', b:'F6', n:'G6', m:'A6', ',':'B6'
  },
  'piano': {
    q:'C3', w:'D3', e:'E3', r:'F3', t:'G3', y:'A3', u:'B3',
    i:'C4', o:'D4', p:'E4', a:'F4', s:'G4', d:'A4', f:'B4',
    g:'C5', h:'D5', j:'E5', k:'F5', l:'G5',
    z:'A5', x:'C6', c:'D6', v:'E6', b:'F6', n:'G6', m:'A6', ',':'B6'
  },
  'handpan': {
    q:'C3', w:'D3', e:'E3', r:'F3', t:'G3', y:'A3', u:'B3',
    i:'C4', o:'D4', p:'E4', a:'F4', s:'G4', d:'A4', f:'B4',
    g:'C5', h:'D5', j:'E5', k:'F5', l:'G5',
    z:'A5', x:'C6', c:'D6', v:'E6', b:'F6', n:'G6', m:'A6', ',':'B6'
  },
  'dan-da': {
    q:'C3', w:'D3', e:'E3', r:'F3', t:'G3', y:'A3', u:'B3',
    i:'C4', o:'D4', p:'E4', a:'F4', s:'G4', d:'A4', f:'B4',
    g:'C5', h:'D5', j:'E5', k:'F5', l:'G5',
    z:'A5', x:'C6', c:'D6', v:'E6', b:'F6', n:'G6', m:'A6', ',':'B6'
  },
  'dan-bau': {
    q:'C3', w:'D3', e:'E3', r:'F3', t:'G3', y:'A3', u:'B3',
    i:'C4', o:'D4', p:'E4', a:'F4', s:'G4', d:'A4', f:'B4',
    g:'C5', h:'D5', j:'E5', k:'F5', l:'G5',
    z:'A5', x:'C6', c:'D6', v:'E6', b:'F6', n:'G6', m:'A6', ',':'B6'
  }
};

const keyRows = [
  ['q','w','e','r','t','y','u','i','o','p'],
  ['a','s','d','f','g','h','j','k','l'],
  ['z','x','c','v','b','n','m',',']
];
const keyOrderFlat = keyRows.flat();
const keyMap = ['z','x','c','v','b','n','m',',']; // legacy note order for quick mapping if needed
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const buffersByInstrument = {}; // instrument -> { name -> AudioBuffer|undefined }
let keymapJson = {}; // loaded from keymap.json
let pressedKeys = new Set();
let shiftHeld = false;

// Song state
let songTokens = []; // [{text: string, notes: ["C4",...], doneSteps: number}]
let songPos = 0; // index in songTokens
let showSongNotes = true;
let highlightKeyboardGuide = true;
let showSolfege = false;
let songMode = false;
let composerMode = false;
let composerSelectedIndex = null; // selected token index for composing

function getCurrentMap(inst = currentInstrument) {
  const fromFile = (keymapJson && keymapJson[inst]) || null;
  const fromDefault = (DEFAULT_KEYMAP && DEFAULT_KEYMAP[inst]) || null;
  return fromFile || fromDefault || {};
}

function toSharpIfNeeded(name, useSharp) {
  if (!useSharp || !name) return name;
  const m = name.match(/^([A-G])(#|b)?(\d)$/);
  if (!m) return name;
  const base = m[1];
  const accidental = m[2] || '';
  const oct = m[3];
  // Only sharpify for F,G,A,C,D when no existing accidental
  const eligible = { F:1, G:1, A:1, C:1, D:1 };
  if (!eligible[base] || accidental) return name;
  // Edge case for E and B are excluded by eligible
  return base + '#' + oct;
}

// Convert note name to solfege with octave (e.g., C4 -> "do 4", F#3 -> "fa# 3")
function noteToSolfege(name) {
  if (!name) return '-';
  const m = name.match(/^([A-G])(#|b)?(\d)$/);
  if (!m) return name;
  const base = m[1];
  const acc = m[2] || '';
  const oct = m[3];
  const map = { C:'do', D:'re', E:'mi', F:'fa', G:'sol', A:'la', B:'si' };
  const syl = map[base] || base.toLowerCase();
  const accTxt = acc === '#' ? '#' : (acc === 'b' ? 'b' : '');
  return syl + accTxt + ' ' + oct;
}

function formatKeyLabel(note) {
  const n = toSharpIfNeeded(note, shiftHeld);
  if (showSolfege) return noteToSolfege(n);
  return n || '-';
}

function ensureAudioContext() {
  if (audioCtx.state === 'suspended') {
    audioCtx.resume().catch(()=>{});
  }
}

// --- Marimba (percussive mallet resonators)
function playMarimba(noteName) {
  ensureAudioContext();
  const f0 = noteToFreq(noteName);
  const now = audioCtx.currentTime;
  const master = audioCtx.createGain(); master.gain.value = 0.95;
  // Short noise burst as excitation
  const burstLen = Math.max(1, Math.floor(audioCtx.sampleRate * 0.012));
  const noiseBuf = audioCtx.createBuffer(1, burstLen, audioCtx.sampleRate);
  const ch = noiseBuf.getChannelData(0);
  for (let i=0;i<burstLen;i++){ ch[i] = (Math.random()*2-1) * (1 - i/burstLen); }
  const noise = audioCtx.createBufferSource(); noise.buffer = noiseBuf; noise.loop = false;
  const nEnv = audioCtx.createGain(); nEnv.gain.setValueAtTime(0.0001, now); nEnv.gain.exponentialRampToValueAtTime(1.0, now + 0.002); nEnv.gain.exponentialRampToValueAtTime(0.0001, now + 0.05);
  // Bar mode ratios for marimba-like timbre (approx)
  const ratios = [1.00, 2.756, 5.404];
  const gains  = [0.9, 0.55, 0.35];
  const Qs     = [18,   14,    12];
  const modes = audioCtx.createGain(); modes.gain.value = 0.9;
  ratios.forEach((r,i)=>{
    const bp = audioCtx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.value = Math.min(f0*r, 12000); bp.Q.value = Qs[i];
    const g  = audioCtx.createGain(); g.gain.value = gains[i];
    noise.connect(nEnv).connect(bp).connect(g).connect(modes);
  });
  // Soft body lowpass for wood tone
  const toneLP = audioCtx.createBiquadFilter(); toneLP.type='lowpass'; toneLP.frequency.value = 4800; toneLP.Q.value = 0.4;
  // Output envelope (decay ~2.2s)
  const out = audioCtx.createGain();
  out.gain.setValueAtTime(0.0001, now);
  out.gain.exponentialRampToValueAtTime(0.9, now + 0.004);
  out.gain.exponentialRampToValueAtTime(0.0001, now + 2.2);
  modes.connect(toneLP).connect(out).connect(master).connect(audioCtx.destination);
  noise.start(now); noise.stop(now + 0.05);
}

function noteToFreq(n) {
  // Parse like C#4, Db4, etc.
  const A4 = 440;
  const map = { C:0, 'C#':1, Db:1, D:2, 'D#':3, Eb:3, E:4, F:5, 'F#':6, Gb:6, G:7, 'G#':8, Ab:8, A:9, 'A#':10, Bb:10, B:11 };
  const m = n.match(/^([A-G](?:#|b)?)(\d)$/);
  if (!m) return 440;
  const [, pc, octStr] = m;
  const octave = parseInt(octStr,10);
  const semitone = map[pc];
  const midi = (octave + 1) * 12 + semitone; // MIDI note number
  const midiA4 = 69;
  return A4 * Math.pow(2, (midi - midiA4) / 12);
}

// --- Flute (Sáo) sustain helpers ---
function startFluteSustain(note) {
  const freq = noteToFreq(note);
  const osc = audioCtx.createOscillator();
  osc.type = 'sine';
  osc.frequency.value = freq;
  const lfo = audioCtx.createOscillator();
  const lfoGain = audioCtx.createGain();
  lfo.frequency.value = 5; // Hz
  lfoGain.gain.value = 10; // cents
  lfo.connect(lfoGain).connect(osc.detune);
  const gain = audioCtx.createGain();
  const now = audioCtx.currentTime;
  gain.gain.setValueAtTime(0.0001, now);
  gain.gain.exponentialRampToValueAtTime(0.55, now + 0.06); // attack
  osc.connect(gain).connect(audioCtx.destination);
  osc.start();
  lfo.start();
  let stopped = false;
  return function stop() {
    if (stopped) return; stopped = true;
    const t = audioCtx.currentTime;
    try {
      gain.gain.cancelScheduledValues(t);
      gain.gain.setValueAtTime(gain.gain.value, t);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);
    } catch(_) {}
    try { osc.stop(t + 0.14); } catch(_) {}
    try { lfo.stop(t + 0.14); } catch(_) {}
  };
}

// --- Đàn bầu sustain helpers (rich vibrato, long sustain)
function startDanBauSustain(note) {
  const freq = noteToFreq(note);
  const osc = audioCtx.createOscillator();
  // Mixture for hơi ấm và giàu hài âm bậc thấp
  const osc2 = audioCtx.createOscillator();
  osc.type = 'sine';
  osc.frequency.value = freq;
  osc2.type = 'triangle';
  osc2.frequency.value = freq * 2; // nhẹ hài bậc 2

  // Vibrato mạnh và chậm hơn sáo
  const lfo = audioCtx.createOscillator();
  const lfoGain = audioCtx.createGain();
  lfo.frequency.value = 5.5; // chậm hơn
  lfoGain.gain.value = 45; // rung rộng hơn (cents)
  lfo.connect(lfoGain).connect(osc.detune);
  // thêm rung nhẹ lệch pha cho osc2
  const lfo2 = audioCtx.createOscillator();
  const lfo2Gain = audioCtx.createGain();
  lfo2.frequency.value = 4.8;
  lfo2Gain.gain.value = 16;
  lfo2.connect(lfo2Gain).connect(osc2.detune);

  // Attack glide: kéo cao độ lên đích trong 120ms
  try {
    osc.detune.setValueAtTime(-20, audioCtx.currentTime);
    osc.detune.linearRampToValueAtTime(0, audioCtx.currentTime + 0.12);
  } catch(_){ }

  // Formant filter để ấm hơn
  const bp = audioCtx.createBiquadFilter();
  bp.type = 'bandpass';
  bp.frequency.value = Math.min(1800, freq * 3);
  bp.Q.value = 0.9;

  // Low-pass dịu bớt chói
  const lp = audioCtx.createBiquadFilter();
  lp.type = 'lowpass';
  lp.frequency.value = 3200;
  lp.Q.value = 0.8;

  // Envelope dài
  const gain = audioCtx.createGain();
  const now = audioCtx.currentTime;
  gain.gain.setValueAtTime(0.0001, now);
  gain.gain.exponentialRampToValueAtTime(0.75, now + 0.09); // attack mượt hơn

  // Wiring
  const mix = audioCtx.createGain(); mix.gain.value = 0.8;
  osc.connect(mix); osc2.connect(mix);
  // Ambience nhẹ với feedback delay
  const delay = audioCtx.createDelay(1.2); delay.delayTime.value = 0.22;
  const fb = audioCtx.createGain(); fb.gain.value = 0.15; delay.connect(fb).connect(delay);
  const wet = audioCtx.createGain(); wet.gain.value = 0.18;
  const dry = audioCtx.createGain(); dry.gain.value = 0.95;
  const pre = audioCtx.createGain();
  mix.connect(bp).connect(lp).connect(pre);
  pre.connect(dry).connect(gain);
  pre.connect(delay).connect(wet).connect(gain);
  gain.connect(audioCtx.destination);
  osc.start(); osc2.start(); lfo.start(); lfo2.start();

  let stopped = false;
  return function stop() {
    if (stopped) return; stopped = true;
    const t = audioCtx.currentTime;
    try {
      gain.gain.cancelScheduledValues(t);
      gain.gain.setValueAtTime(gain.gain.value, t);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 1.8); // long release hơn
    } catch(_){ }
    try { osc.stop(t + 1.25); osc2.stop(t + 1.25); lfo.stop(t + 1.25); lfo2.stop(t + 1.25); } catch(_){ }
  };
}

// --- Tank Drum modal synthesis (rich, ringing, ambient)
function playTankDrum(noteName) {
  const freq = noteToFreq(noteName);
  const now = audioCtx.currentTime;
  const master = audioCtx.createGain(); master.gain.value = 1.0;
  // Noise excitation
  const noiseBuf = audioCtx.createBuffer(1, Math.max(1, Math.floor(audioCtx.sampleRate * 0.06)), audioCtx.sampleRate);
  const ch = noiseBuf.getChannelData(0);
  for (let i=0;i<ch.length;i++){ ch[i] = (Math.random()*2-1) * (1 - i/ch.length); }
  const noise = audioCtx.createBufferSource(); noise.buffer = noiseBuf; noise.loop = false;
  const nEnv = audioCtx.createGain(); nEnv.gain.setValueAtTime(0.0001, now); nEnv.gain.exponentialRampToValueAtTime(0.7, now + 0.002); nEnv.gain.exponentialRampToValueAtTime(0.0001, now + 0.08);
  // Modal bandpass stack (slightly darker balance)
  const ratios = [1.0, 1.45, 1.9, 2.4];
  const gains  = [0.95, 0.55, 0.35, 0.22];
  const Qs     = [16, 12, 10, 9];
  const modes = audioCtx.createGain(); modes.gain.value = 0.85;
  ratios.forEach((r,i)=>{
    const bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = Math.min(freq*r, 12000); bp.Q.value = Qs[i];
    const g = audioCtx.createGain(); g.gain.value = gains[i];
    noise.connect(nEnv).connect(bp).connect(g).connect(modes);
  });
  // Body oscillators (more fundamental, less upper content)
  const osc1 = audioCtx.createOscillator(); osc1.type='sine'; osc1.frequency.value = freq;
  const osc2 = audioCtx.createOscillator(); osc2.type='triangle'; osc2.frequency.value = freq*2.0;
  const body = audioCtx.createGain();
  body.gain.setValueAtTime(0.0001, now);
  body.gain.exponentialRampToValueAtTime(0.65, now + 0.012);
  body.gain.exponentialRampToValueAtTime(0.0001, now + 2.9);
  osc1.connect(body); osc2.connect(body);
  // Ambience
  const delay = audioCtx.createDelay(1.0); delay.delayTime.value = 0.21;
  const fb = audioCtx.createGain(); fb.gain.value = 0.18; delay.connect(fb).connect(delay);
  const wet = audioCtx.createGain(); wet.gain.value = 0.2;
  const dry = audioCtx.createGain(); dry.gain.value = 0.92;
  // Gentle tone shaper to warm highs
  const warmLP = audioCtx.createBiquadFilter(); warmLP.type = 'lowpass'; warmLP.frequency.value = 3200; warmLP.Q.value = 0.5;
  const premix = audioCtx.createGain();
  modes.connect(premix); body.connect(premix);
  premix.connect(dry).connect(master);
  premix.connect(delay).connect(wet).connect(master);
  master.connect(warmLP).connect(audioCtx.destination);
  // Start/stop
  const stopAt = now + 3.2;
  noise.start(now); noise.stop(now + 0.08);
  osc1.start(now); osc2.start(now);
  try { osc1.stop(stopAt); osc2.stop(stopAt); } catch(_) {}
}

// --- Guitar (plucked string, Karplus–Strong style)
function playGuitar(noteName){
  ensureAudioContext();
  const f = noteToFreq(noteName);
  const now = audioCtx.currentTime;
  const sr = audioCtx.sampleRate;
  const period = 1 / Math.max(40, Math.min(2000, f));
  // Excitation burst (pick) – slightly brighter, short
  const excLen = Math.max(1, Math.floor(sr * 0.012));
  const buf = audioCtx.createBuffer(1, excLen, sr);
  const ch = buf.getChannelData(0);
  for (let i=0;i<excLen;i++) ch[i] = (Math.random()*2-1) * (1 - i/excLen);
  const src = audioCtx.createBufferSource(); src.buffer = buf; src.loop = false;
  // Pick-position feedforward comb (src - delayed(src)) to shape notch pattern
  const pickDelay = audioCtx.createDelay(0.01);
  // Pick position approx 20–25% of string length
  pickDelay.delayTime.value = Math.min(0.008, period * 0.23);
  const inv = audioCtx.createGain(); inv.gain.value = -0.8;
  const pickMix = audioCtx.createGain(); pickMix.gain.value = 1.0;
  src.connect(pickMix);
  src.connect(pickDelay).connect(inv);
  inv.connect(pickMix);
  // Loop with dual damping (lowpass to remove highs, highpass to remove DC)
  const loopDelay = audioCtx.createDelay(1.0); loopDelay.delayTime.value = period;
  const fb = audioCtx.createGain(); fb.gain.value = 0.6; // sustain
  const lpDamp = audioCtx.createBiquadFilter(); lpDamp.type='lowpass'; lpDamp.frequency.value = 3000; lpDamp.Q.value = 0.25;
  const hpDamp = audioCtx.createBiquadFilter(); hpDamp.type='highpass'; hpDamp.frequency.value = 60; hpDamp.Q.value = 0.7;
  loopDelay.connect(lpDamp).connect(hpDamp).connect(fb).connect(loopDelay);
  // Body resonances (two bands)
  const body1 = audioCtx.createBiquadFilter(); body1.type='bandpass'; body1.frequency.value = Math.max(180, Math.min(260, f*0.8)); body1.Q.value = 1.0;
  const body2 = audioCtx.createBiquadFilter(); body2.type='bandpass'; body2.frequency.value = Math.max(300, Math.min(420, f*1.1)); body2.Q.value = 0.8;
  // Output envelope and tone
  const out = audioCtx.createGain();
  out.gain.setValueAtTime(0.0001, now);
  out.gain.exponentialRampToValueAtTime(0.9, now + 0.005);
  out.gain.exponentialRampToValueAtTime(0.0001, now + 2.6);
  const outLP = audioCtx.createBiquadFilter(); outLP.type='lowpass'; outLP.frequency.value = 3600; outLP.Q.value = 0.5;
  const postGain = audioCtx.createGain(); postGain.gain.value = 1.3;
  // Wire graph
  pickMix.connect(loopDelay);
  loopDelay.connect(body1).connect(body2).connect(out).connect(outLP).connect(postGain).connect(audioCtx.destination);
  src.start(now); src.stop(now + 0.02);
}

async function loadSamplesForInstrument(instKey) {
  const inst = instruments[instKey];
  const bufs = buffersByInstrument[instKey] || (buffersByInstrument[instKey] = {});
  for (let i = 0; i < inst.notes.length; i++) {
    const name = inst.notes[i];
    const path = inst.pathPrefix + name + '.wav';
    try {
      const res = await fetch(path);
      if (!res.ok) throw new Error('Missing sample');
      const ab = await res.arrayBuffer();
      const buf = await audioCtx.decodeAudioData(ab);
      bufs[name] = buf;
    } catch (e) {
      bufs[name] = undefined; // fallback to synth
    }
  }
}

async function loadKeymap() {
  // Prefer shared JS keymap when available; otherwise fall back to DEFAULT_KEYMAP
  if (window && window.SHARED_KEYMAP) {
    const shared = window.SHARED_KEYMAP;
    keymapJson = {
      'piano': shared,
      'tank-drum': shared,
      'sao': shared,
      'marimba': shared,
      'handpan': shared,
      'dan-da': shared,
      'dan-bau': shared
    };
    return;
  }
  keymapJson = DEFAULT_KEYMAP;
}

function makeKeyButton(k, mappedNote, available) {
  const btn = document.createElement('div');
  btn.className = 'key';
  btn.setAttribute('data-key', k);
  const labelNote = toSharpIfNeeded(mappedNote, shiftHeld);
  btn.innerHTML = `<div class="k">${k.toUpperCase()}</div><div class="n">${formatKeyLabel(mappedNote)}</div>`;
  if (!available && mappedNote) btn.classList.add('unavailable');
  btn.addEventListener('pointerdown', ()=> {
    ensureAudioContext();
    btn.classList.add('active');
    const playName = toSharpIfNeeded(mappedNote, shiftHeld);
    // Composer capture first (even if not playable)
    if (composerMode && composerSelectedIndex !== null && playName) {
      const tok = songTokens[composerSelectedIndex];
      if (tok && tok.text !== '\n') {
        tok.notes = tok.notes || [];
        tok.notes.push(playName);
        renderSong();
      }
    }
    if (playName && available) {
      if (currentInstrument === 'piano' && window.tonePiano) {
        // Song guidance advances only in song mode
        if (songMode) handleNotePlayed(playName);
        window.tonePiano.attack(playName);
        btn.dataset.activeNote = playName;
      } else if (currentInstrument === 'sao') {
        // Sáo sustain while holding
        if (songMode) handleNotePlayed(playName);
        btn._fluteStop = startFluteSustain(playName);
      } else if (currentInstrument === 'dan-bau') {
        if (songMode) handleNotePlayed(playName);
        btn._danBauStop = startDanBauSustain(playName);
      } else {
        playNote(playName);
      }
    }
  });
  btn.addEventListener('pointerup', ()=> {
    btn.classList.remove('active');
    if (currentInstrument === 'piano' && window.tonePiano && btn.dataset.activeNote) {
      window.tonePiano.release(btn.dataset.activeNote);
      delete btn.dataset.activeNote;
    } else if (currentInstrument === 'sao' && btn._fluteStop) {
      try { btn._fluteStop(); } catch(_){}
      delete btn._fluteStop;
    } else if (currentInstrument === 'dan-bau' && btn._danBauStop) {
      try { btn._danBauStop(); } catch(_){ }
      delete btn._danBauStop;
    }
  });
  btn.addEventListener('pointerleave', ()=> {
    btn.classList.remove('active');
    if (currentInstrument === 'piano' && window.tonePiano && btn.dataset.activeNote) {
      window.tonePiano.release(btn.dataset.activeNote);
      delete btn.dataset.activeNote;
    } else if (currentInstrument === 'sao' && btn._fluteStop) {
      try { btn._fluteStop(); } catch(_){ }
      delete btn._fluteStop;
    } else if (currentInstrument === 'dan-bau' && btn._danBauStop) {
      try { btn._danBauStop(); } catch(_){ }
      delete btn._danBauStop;
    }
  });
  btn.addEventListener('pointercancel', ()=> {
    btn.classList.remove('active');
    if (currentInstrument === 'piano' && window.tonePiano && btn.dataset.activeNote) {
      window.tonePiano.release(btn.dataset.activeNote);
      delete btn.dataset.activeNote;
    } else if (currentInstrument === 'sao' && btn._fluteStop) {
      try { btn._fluteStop(); } catch(_){ }
      delete btn._fluteStop;
    } else if (currentInstrument === 'dan-bau' && btn._danBauStop) {
      try { btn._danBauStop(); } catch(_){ }
      delete btn._danBauStop;
    }
  });
  return btn;
}

function playNote(name) {
  // Validate against song if any
  if (songMode) handleNotePlayed(name);
  const synthType = instruments[currentInstrument].synth;
  if (synthType === 'marimba') { playMarimba(name); return; }
  if (currentInstrument === 'piano' && window.tonePiano) {
    window.tonePiano.play(name);
    return;
  }
  const bufs = buffersByInstrument[currentInstrument] || {};
  const buf = bufs[name];
  (window._playing = window._playing || []);
  if (buf) {
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    const gain = audioCtx.createGain();
    gain.gain.value = 1.0;
    src.connect(gain).connect(audioCtx.destination);
    src.start();
    window._playing.push({ stop: () => { try { src.stop(); } catch(_){} }, node: src });
    src.onended = ()=> {
      const idx = window._playing.findIndex(o=>o.node===src);
      if (idx>=0) window._playing.splice(idx,1);
    };
    return;
  }
  const freq = noteToFreq(name);
  if (synthType === 'percussive') {
    playTankDrum(name);
    return;
  } else if (synthType === 'handpan') {
    // Handpan: soft attack, rich overtones, long decay (~3.2s)
    const oscFund = audioCtx.createOscillator();
    const oscOver = audioCtx.createOscillator();
    oscFund.type = 'sine';
    oscOver.type = 'triangle';
    oscFund.frequency.value = freq;
    oscOver.frequency.value = freq * 2.01;
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = freq * 1.4;
    filter.Q.value = 7;
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(0.9, now + 0.008);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 1.8);
    oscFund.connect(filter);
    oscOver.connect(filter);
    filter.connect(gain).connect(audioCtx.destination);
    oscFund.start();
    oscOver.start();
    const stopAt = now + 1.85;
    oscFund.stop(stopAt);
    oscOver.stop(stopAt);
    const playingObj = { stop: () => { try { oscFund.stop(); } catch(_){} try { oscOver.stop(); } catch(_){} }, node: oscFund };
    window._playing.push(playingObj);
    oscFund.onended = () => {
      const idx = window._playing.indexOf(playingObj);
      if (idx>=0) window._playing.splice(idx,1);
    };
  } else if (synthType === 'lithophone') {
    // Lithophone (Đàn đá): bright mallet, glassy tone, medium-long decay (~2.4s)
    const osc = audioCtx.createOscillator();
    const oscH = audioCtx.createOscillator();
    osc.type = 'sine';
    oscH.type = 'square';
    osc.frequency.value = freq;
    oscH.frequency.value = freq * 3.0;
    const hp = audioCtx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 200;
    const bp = audioCtx.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.value = freq * 1.1;
    bp.Q.value = 10;
    const gain = audioCtx.createGain();
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(0.85, now + 0.005);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 2.4);
    osc.connect(hp).connect(bp);
    oscH.connect(bp);
    bp.connect(gain).connect(audioCtx.destination);
    osc.start();
    oscH.start();
    const stopAt = now + 2.45;
    osc.stop(stopAt);
    oscH.stop(stopAt);
    const playingObj = { stop: () => { try { osc.stop(); } catch(_){} try { oscH.stop(); } catch(_){} }, node: osc };
    window._playing.push(playingObj);
    osc.onended = () => {
      const idx = window._playing.indexOf(playingObj);
      if (idx>=0) window._playing.splice(idx,1);
    };
  } else {
    // Sáo: longer sustain (~2.2s) with gentle vibrato
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const lfo = audioCtx.createOscillator();
    const lfoGain = audioCtx.createGain();
    lfo.frequency.value = 5; // 5 Hz vibrato
    lfoGain.gain.value = 10; // cents
    lfo.connect(lfoGain).connect(osc.detune);
    const gain = audioCtx.createGain();
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(0.55, now + 0.08);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 2.2);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start();
    lfo.start();
    const stopAt = now + 2.25;
    osc.stop(stopAt);
    lfo.stop(stopAt);
    const playingObj = { stop: () => { try { osc.stop(); } catch(_){} try { lfo.stop(); } catch(_){} }, node: osc };
    window._playing.push(playingObj);
    osc.onended = () => {
      const idx = window._playing.indexOf(playingObj);
      if (idx>=0) window._playing.splice(idx,1);
    };
  }
}

function stopAll() {
  if (!window._playing) return;
  window._playing.forEach(o=>{ try{ o.stop(); } catch(e){} });
  window._playing = [];
  if (currentInstrument === 'piano' && window.tonePiano) {
    window.tonePiano.stopAll();
  }
  if (window._fluteActiveByKey) {
    for (const k in window._fluteActiveByKey) {
      try { window._fluteActiveByKey[k](); } catch(_){ }
      delete window._fluteActiveByKey[k];
    }
  }
}

function updateSongModeUI() {
  const sc = document.querySelector('.song-controls');
  const sa = document.getElementById('songArea');
  if (!sc || !sa) return;
  const show = songMode || composerMode;
  sc.style.display = show ? '' : 'none';
  sa.style.display = show ? '' : 'none';
  if (!songMode) {
    // Clear any guide highlights when hiding
    document.querySelectorAll('.key.guide').forEach(el=> el.classList.remove('guide'));
    document.querySelectorAll('.key.guide-sharp').forEach(el=> el.classList.remove('guide-sharp'));
  } else {
    updateKeyboardGuideHighlight();
  }
  // Composer controls visibility
  const cc = document.getElementById('composerControls');
  if (cc) cc.style.display = composerMode ? '' : 'none';
  const cst = document.getElementById('composerStaff');
  if (cst) cst.style.display = composerMode ? '' : 'none';
  if (composerMode) renderComposerStaff();
}

function rebuildUI() {
  const kb = document.getElementById('keyboard');
  kb.innerHTML = '';
  const inst = instruments[currentInstrument];
  const currentMap = getCurrentMap();
  // Ensure CSS --cols matches the longest row for perfect centering
  try {
    const maxLen = Math.max(...keyRows.map(r=> r.length));
    kb.style.setProperty('--cols', String(maxLen));
  } catch(_){}
  keyRows.forEach((rowKeys, idx)=>{
    const row = document.createElement('div');
    row.className = 'row ' + (idx===0?'r1':idx===1?'r2':'r3');
    // Inform CSS about how many keys this row has for trailing spacer calc
    try { row.style.setProperty('--len', String(rowKeys.length)); } catch(_){}
    rowKeys.forEach(k=>{
      const note = currentMap[k] || '';
      const available = !!note && (inst.notes.length === 0 || inst.notes.includes(note));
      row.appendChild(makeKeyButton(k, note, available));
    });
    kb.appendChild(row);
  });
}

function refreshLabelsForShift() {
  const currentMap = getCurrentMap();
  for (const k of keyRows.flat()) {
    const note = currentMap[k] || '';
    const el = document.querySelector(`[data-key="${CSS.escape(k)}"] .n`);
    if (el) el.textContent = formatKeyLabel(note);
  }
}

// --- Song parsing and rendering ---
function parseSong(text) {
  const lines = text.split(/\r?\n/);
  const seq = [];
  const tokenRe = /([^{}\s]+|\[[^\]]+\])((?:\{[A-G](?:#|b)?\d\})+)/g;
  for (let li = 0; li < lines.length; li++) {
    const line = lines[li];
    let m;
    let matched = false;
    tokenRe.lastIndex = 0;
    while ((m = tokenRe.exec(line)) !== null) {
      matched = true;
      const textPart = m[1];
      const notesPart = m[2];
      const noteMatches = Array.from(notesPart.matchAll(/\{([A-G](?:#|b)?\d)\}/g)).map(x=>x[1]);
      seq.push({ text: textPart, notes: noteMatches, doneSteps: 0 });
    }
    if (!matched && line.trim()) {
      const words = line.trim().split(/\s+/);
      for (const w of words) seq.push({ text: w, notes: [], doneSteps: 0 });
    }
    if (li < lines.length - 1) seq.push({ text: '\n', notes: [], doneSteps: 0 });
  }
  return seq;
}

function renderSong() {
  const area = document.getElementById('songArea');
  area.innerHTML = '';
  let line = document.createElement('div');
  area.appendChild(line);
  let lineCount = 1;
  for (let i = 0; i < songTokens.length; i++) {
    const tok = songTokens[i];
    if (tok.text === '\n') { line = document.createElement('div'); area.appendChild(line); lineCount++; continue; }
    const span = document.createElement('span');
    span.className = 'token';
    if (i === songPos) span.classList.add('current');
    if (composerMode && i === composerSelectedIndex) span.classList.add('editing');
    span.textContent = tok.text;
    const hints = document.createElement('span');
    hints.className = 'hints';
    if (showSongNotes && tok.notes && tok.notes.length) {
      hints.textContent = tok.notes.join(' ');
    } else {
      hints.textContent = '';
    }
    span.appendChild(hints);
    span.setAttribute('data-index', String(i));
    span.style.cursor = composerMode ? 'pointer' : 'default';
    span.addEventListener('click', ()=>{
      if (!composerMode) return;
      composerSelectedIndex = i;
      updateComposerStatus();
      renderSong();
      // If this word already has notes, play them immediately
      const tokNow = songTokens[i];
      if (tokNow && tokNow.notes && tokNow.notes.length) {
        try { ensureAudioContext(); } catch(_){ }
        tokNow.notes.forEach((nn, idx)=> setTimeout(()=>{ try { playNote(nn); } catch(_){ } }, idx * 180));
      }
    });
    line.appendChild(span);
  }
  updateKeyboardGuideHighlight();
  // Toggle scroll if composer mode and more than ~6 lines
  if (typeof composerMode !== 'undefined' && composerMode && lineCount > 6) area.classList.add('scrollable');
  else area.classList.remove('scrollable');
}

function updateSongHighlight() {
  const tokens = document.querySelectorAll('#songArea .token');
  tokens.forEach(el=> el.classList.remove('current','done'));
  // Find next visible token (skip newline placeholders)
  let visIdx = songPos;
  while (visIdx < songTokens.length && songTokens[visIdx].text === '\n') visIdx++;
  if (visIdx < songTokens.length) {
    const el = document.querySelector(`#songArea .token[data-index="${visIdx}"]`);
    if (el) el.classList.add('current');
  }
  songTokens.forEach((t, idx)=>{
    if (t.notes.length>0 && t.doneSteps >= t.notes.length) {
      const el = document.querySelector(`#songArea .token[data-index="${idx}"]`);
      if (el) el.classList.add('done');
    }
    if (showSongNotes) {
      const el = document.querySelector(`#songArea .token[data-index="${idx}"] .hints`);
      if (el) {
        if (t.notes.length) el.textContent = t.notes.join(' ');
        else el.textContent = '';
      }
    }
  });
  updateKeyboardGuideHighlight();
}

function handleNotePlayed(note) {
  if (!songTokens.length) return;
  // Skip non-note tokens
  while (songPos < songTokens.length && songTokens[songPos].notes.length === 0) songPos++;
  if (songPos >= songTokens.length) return;
  const cur = songTokens[songPos];
  const expected = cur.notes[cur.doneSteps];
  if (!expected) { songPos++; updateSongHighlight(); return; }
  if (note === expected) {
    cur.doneSteps++;
    if (cur.doneSteps >= cur.notes.length) {
      songPos++;
      // Immediately skip through newline tokens so next line's first word is highlighted
      while (songPos < songTokens.length && songTokens[songPos].text === '\n') songPos++;
    }
    updateSongHighlight();
  }
}

function updateKeyboardGuideHighlight() {
  // Clear previous guide highlights
  document.querySelectorAll('.key.guide').forEach(el=> el.classList.remove('guide'));
  document.querySelectorAll('.key.guide-sharp').forEach(el=> el.classList.remove('guide-sharp'));
  if (!songMode) return;
  if (!highlightKeyboardGuide) return;
  if (!songTokens.length) return;
  // Find next token needing a note
  let pos = songPos;
  while (pos < songTokens.length && songTokens[pos].notes.length === 0) pos++;
  if (pos >= songTokens.length) return;
  const cur = songTokens[pos];
  const expected = cur.notes[cur.doneSteps];
  if (!expected) return;
  const isSharp = expected.includes('#');
  // Find keys that map to expected note for current instrument
  const currentMap = getCurrentMap();
  for (const [k, v] of Object.entries(currentMap)) {
    // Match either direct mapping or sharped form
    if (v === expected || toSharpIfNeeded(v, true) === expected) {
      const keyEl = document.querySelector(`[data-key="${CSS.escape(k)}"]`);
      if (keyEl) keyEl.classList.add(isSharp ? 'guide-sharp' : 'guide');
    }
  }
}

(async ()=>{
  await loadKeymap();
  rebuildUI();
  await loadSamplesForInstrument(currentInstrument);
  console.log('Samples loaded for', currentInstrument);
  // Initialize song mode UI (default hidden)
  updateSongModeUI();
})();

// Safety: stop all sustained sounds on tab hide or window blur
window.addEventListener('blur', stopAll);
document.addEventListener('visibilitychange', ()=>{ if (document.hidden) stopAll(); });

document.getElementById('instrumentSelect').addEventListener('change', async (e)=>{
  currentInstrument = e.target.value;
  rebuildUI();
  if (currentInstrument !== 'piano') {
    await loadSamplesForInstrument(currentInstrument);
  }
  updateKeyboardGuideHighlight();
});

// Disable instrument selection via keyboard to avoid conflicts with playing keys
(()=>{
  const sel = document.getElementById('instrumentSelect');
  if (!sel) return;
  const block = ev => { ev.preventDefault(); ev.stopPropagation(); };
  ['keydown','keypress','keyup'].forEach(type=> sel.addEventListener(type, block));
})();

// Paste song handlers (modal)
function showPasteModal(show) {
  const el = document.getElementById('pasteModal');
  if (!el) return;
  el.style.display = show ? '' : 'none';
  if (show) setTimeout(()=>{ const ta = document.getElementById('songPasteModal'); if (ta) ta.focus(); }, 0);
}
document.getElementById('pasteSongBtn').addEventListener('click', ()=>{
  showPasteModal(true);
});
document.getElementById('pasteCancel').addEventListener('click', ()=>{
  showPasteModal(false);
});
document.getElementById('pasteApply').addEventListener('click', ()=>{
  const ta = document.getElementById('songPasteModal');
  const txt = (ta && ta.value || '').trim();
  if (!txt) { showPasteModal(false); return; }
  songTokens = parseSong(txt);
  songPos = 0;
  renderSong();
  updateSongHighlight();
  updateComposerStatus();
  showPasteModal(false);
});

window.addEventListener('keydown', (e)=>{
  // Ignore global keyboard handling when user is focused on form controls
  const ae = document.activeElement;
  if (ae && ['INPUT','TEXTAREA','SELECT','BUTTON'].includes(ae.tagName)) return;
  const k = e.key.toLowerCase();
  if (k === 'shift') { if (!shiftHeld) { shiftHeld = true; refreshLabelsForShift(); } return; }
  if (pressedKeys.has(k)) return; // avoid repeats until keyup
  pressedKeys.add(k);
  const btn = document.querySelector(`[data-key="${CSS.escape(k)}"]`);
  if (btn) btn.classList.add('active');
  const currentMap = getCurrentMap();
  let name = currentMap[k];
  name = toSharpIfNeeded(name, e.shiftKey || shiftHeld);
  const inst = instruments[currentInstrument];
  const available = !!name && (inst.notes.length === 0 || inst.notes.includes(name));
  // Composer capture first (even if not playable)
  if (composerMode && composerSelectedIndex !== null && name) {
    const tok = songTokens[composerSelectedIndex];
    if (tok && tok.text !== '\n') {
      tok.notes = tok.notes || [];
      tok.notes.push(name);
      renderSong();
    }
  }
  if (name && available) {
    ensureAudioContext();
    if (currentInstrument === 'piano' && window.tonePiano) {
      // Song guidance advances only in song mode
      if (songMode) handleNotePlayed(name);
      window.tonePiano.attack(name);
      // store mapping for release
      (window._pianoActiveByKey = window._pianoActiveByKey || {})[k] = name;
    } else if (currentInstrument === 'sao') {
      // Sáo sustain while key is held
      if (songMode) handleNotePlayed(name);
      const stop = startFluteSustain(name);
      (window._fluteActiveByKey = window._fluteActiveByKey || {})[k] = stop;
      if (btn) btn._fluteStop = stop;
    } else if (currentInstrument === 'dan-bau') {
      if (songMode) handleNotePlayed(name);
      const stop = startDanBauSustain(name);
      (window._danBauActiveByKey = window._danBauActiveByKey || {})[k] = stop;
      if (btn) btn._danBauStop = stop;
    } else {
      playNote(name);
    }
  }
});

window.addEventListener('keyup', (e)=>{
  const k = e.key.toLowerCase();
  if (k === 'shift') { shiftHeld = false; refreshLabelsForShift(); return; }
  pressedKeys.delete(k);
  const btn = document.querySelector(`[data-key="${CSS.escape(k)}"]`);
  if (btn) btn.classList.remove('active');
  if (currentInstrument === 'piano' && window.tonePiano && window._pianoActiveByKey && window._pianoActiveByKey[k]) {
    const note = window._pianoActiveByKey[k];
    window.tonePiano.release(note);
    delete window._pianoActiveByKey[k];
  } else if (currentInstrument === 'sao' && window._fluteActiveByKey && window._fluteActiveByKey[k]) {
    const stop = window._fluteActiveByKey[k];
    try { stop(); } catch(_){ }
    delete window._fluteActiveByKey[k];
  } else if (currentInstrument === 'sao' && btn && btn._fluteStop) {
    // Fallback in case the global map missed this key
    try { btn._fluteStop(); } catch(_){ }
    delete btn._fluteStop;
  } else if (currentInstrument === 'dan-bau' && window._danBauActiveByKey && window._danBauActiveByKey[k]) {
    const stop = window._danBauActiveByKey[k];
    try { stop(); } catch(_){ }
    delete window._danBauActiveByKey[k];
  } else if (currentInstrument === 'dan-bau' && btn && btn._danBauStop) {
    try { btn._danBauStop(); } catch(_){ }
    delete btn._danBauStop;
  }
});

// Song UI handlers
document.getElementById('loadSongBtn').addEventListener('click', async ()=>{
  const inp = document.getElementById('songFile');
  const file = inp.files && inp.files[0];
  if (!file) return;
  const txt = await file.text();
  songTokens = parseSong(txt);
  songPos = 0;
  renderSong();
  updateSongHighlight();
});

document.getElementById('resetSongBtn').addEventListener('click', ()=>{
  songTokens.forEach(t=> t.doneSteps = 0);
  songPos = 0;
  updateSongHighlight();
});

// Toggle handlers
document.getElementById('toggleShowNotes').addEventListener('change', (e)=>{
  showSongNotes = !!e.target.checked;
  renderSong();
  updateSongHighlight();
});
document.getElementById('toggleHighlightKeys').addEventListener('change', (e)=>{
  highlightKeyboardGuide = !!e.target.checked;
  updateKeyboardGuideHighlight();
});
document.getElementById('toggleSolfege').addEventListener('change', (e)=>{
  showSolfege = !!e.target.checked;
  refreshLabelsForShift();
});
document.getElementById('toggleSongMode').addEventListener('change', (e)=>{
  songMode = !!e.target.checked;
  updateSongModeUI();
});
document.getElementById('toggleComposer').addEventListener('change', (e)=>{
  composerMode = !!e.target.checked;
  if (!composerMode) composerSelectedIndex = null;
  updateComposerStatus();
  renderSong();
  updateSongModeUI();
});

function updateComposerStatus() {
  const el = document.getElementById('composerStatus');
  if (!el) return;
  if (!composerMode) { el.textContent = 'Soạn nhạc đang tắt'; return; }
  if (composerSelectedIndex === null) { el.textContent = 'Chọn một chữ để thêm nốt...'; return; }
  const tok = songTokens[composerSelectedIndex];
  if (!tok) { el.textContent = 'Không có chữ được chọn'; return; }
  const notes = (tok.notes && tok.notes.length) ? tok.notes.join(' ') : '(chưa có nốt)';
  el.textContent = `Đang chọn: "${tok.text}"  |  Nốt: ${notes}`;
}

document.getElementById('composerClearBtn').addEventListener('click', ()=>{
  if (!composerMode || composerSelectedIndex === null) return;
  const tok = songTokens[composerSelectedIndex];
  if (!tok || tok.text === '\n') return;
  tok.notes = [];
  renderSong();
  updateComposerStatus();
});

function serializeSongToTxt() {
  const parts = [];
  for (let i = 0; i < songTokens.length; i++) {
    const tok = songTokens[i];
    if (tok.text === '\n') { parts.push('\n'); continue; }
    const notes = (tok.notes || []).map(n=>`{${n}}`).join('');
    parts.push(tok.text + notes + ' ');
  }
  return parts.join('').replace(/[ ]+\n/g, '\n').trim();
}

document.getElementById('composerSaveBtn').addEventListener('click', ()=>{
  const txt = serializeSongToTxt();
  const nameInput = document.getElementById('composerFileName');
  let filename = (nameInput && nameInput.value || '').trim();
  if (!filename) filename = 'bai-hat.txt';
  if (!/\.txt$/i.test(filename)) filename += '.txt';
  const blob = new Blob([txt], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});
</script>
<!-- Tone.js and piano layer -->
<script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
<script src="./tone.js"></script>
<script>
  const _svgNS = 'http://www.w3.org/2000/svg';
  function _csEl(tag, attrs){ const el = document.createElementNS(_svgNS, tag); for (const k in attrs) el.setAttribute(k, attrs[k]); return el; }
  function _csParse(name){ const m = String(name).trim().match(/^([A-G])(#|b)?(\d)$/i); if(!m) return null; return { l:m[1].toUpperCase(), a:m[2]||'', o:parseInt(m[3],10) }; }
  function _csNameToMidi(name){ const p=_csParse(name); if(!p) return null; const ord=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B']; let pc=p.l+(p.a||''); if(pc.endsWith('b')){ const fm={Db:'C#',Eb:'D#',Gb:'F#',Ab:'G#',Bb:'A#'}; pc=fm[pc]||pc; } const idx=ord.indexOf(pc); if(idx<0) return null; return (p.o+1)*12+idx; }
  function _csStep(name){ const map={C:0,D:1,E:2,F:3,G:4,A:5,B:6}; const p=_csParse(name); if(!p) return 0; return (p.o-4)*7 + (map[p.l]-map.E);
  }
  function _csDrawStaff(svg, width){ svg.innerHTML=''; const W=width,H=220; svg.setAttribute('viewBox',`0 0 ${W} ${H}`); const left=40,right=W-20,top=40,gap=14; for(let i=0;i<5;i++){ const y=top+i*gap; svg.appendChild(_csEl('line',{x1:left,y1:y,x2:right,y2:y, class:'staff-line'})); } svg.appendChild(_csEl('line',{x1:right-10,y1:top,x2:right-10,y2:top+4*gap, class:'barline'})); return {left,top,gap,right}; }
  function _csDrawNote(svg,x,name,m){ const step=_csStep(name); const yE4=m.top+4*m.gap; const y=yE4 - (m.gap/2)*step; const g=_csEl('g',{class:'note','data-name':String(name).toUpperCase()}); svg.appendChild(g); g.appendChild(_csEl('ellipse',{cx:x,cy:y,rx:10,ry:8,transform:`rotate(-20 ${x} ${y})`, class:'notehead'})); if (y>m.top+2*m.gap) g.appendChild(_csEl('line',{x1:x+9,y1:y,x2:x+9,y2:y-36,class:'staff-line'})); else g.appendChild(_csEl('line',{x1:x-9,y1:y,x2:x-9,y2:y+36,class:'staff-line'})); const low=m.top+4*m.gap, hi=m.top; if (y>low){ for(let yy=low+m.gap; yy<=y; yy+=m.gap){ g.appendChild(_csEl('line',{x1:x-14,y1:yy,x2:x+14,y2:yy,class:'ledger'})); } } if (y<hi){ for(let yy=hi-m.gap; yy>=y; yy-=m.gap){ g.appendChild(_csEl('line',{x1:x-14,y1:yy,x2:x+14,y2:yy,class:'ledger'})); } } const label=_csEl('text',{x:x+18,y:y+5,class:'note-label'}); label.textContent=String(name).toUpperCase(); g.appendChild(label);
    // Sustain behavior for sáo/đàn bầu on staff
    const startPlay = ()=>{
      ensureAudioContext();
      const nn = String(name).toUpperCase();
      // Composer capture first (like keyboard path)
      if (typeof composerMode !== 'undefined' && composerMode && composerSelectedIndex !== null) {
        const tok = (typeof songTokens !== 'undefined') ? songTokens[composerSelectedIndex] : null;
        if (tok && tok.text !== '\n') {
          tok.notes = tok.notes || [];
          tok.notes.push(nn);
          if (typeof renderSong === 'function') renderSong();
          if (typeof updateComposerStatus === 'function') updateComposerStatus();
        }
      }
      if (typeof currentInstrument !== 'undefined' && currentInstrument === 'sao') {
        g._stop = (typeof startFluteSustain === 'function') ? startFluteSustain(nn) : null;
      } else if (typeof currentInstrument !== 'undefined' && currentInstrument === 'dan-bau') {
        g._stop = (typeof startDanBauSustain === 'function') ? startDanBauSustain(nn) : null;
      } else {
        if (typeof playNote === 'function') playNote(nn);
      }
    };
    const stopPlay = ()=>{
      if (g._stop) { try { g._stop(); } catch(_){} g._stop = null; }
    };
    g.addEventListener('pointerdown', startPlay);
    g.addEventListener('pointerup', stopPlay);
    g.addEventListener('pointerleave', stopPlay);
    g.addEventListener('pointercancel', stopPlay);
  }
  function _csBuildFromC(o){ const o2=parseInt(o,10); return [`C${o2}`,`D${o2}`,`E${o2}`,`F${o2}`,`G${o2}`,`A${o2}`,`B${o2}`,`C${o2+1}`]; }
  function renderComposerStaff(){ const wrap=document.getElementById('composerStaff'); if (!wrap || wrap.style.display==='none') return; const svg=document.getElementById('composerStaffSvg'); let arr=[..._csBuildFromC(3),..._csBuildFromC(4),..._csBuildFromC(5)]; const seen=new Set(); arr=arr.filter(n=>{ const m=_csNameToMidi(n); if(m==null||seen.has(m)) return false; seen.add(m); return true; }).sort((a,b)=>(_csNameToMidi(a)||0)-(_csNameToMidi(b)||0)); const left=40; const startX=left+70; const spacing=52; const tail=90; const width = startX + spacing * Math.max(0, arr.length-1) + tail; const met=_csDrawStaff(svg, width); let x=startX; for(const n of arr){ _csDrawNote(svg,x,n,met); x+=spacing; }
  }
</script>
</body>
</html>
