<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Keyboard Music</title>
<link rel="icon" href='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="32" fill="%23fff3e6"/><path d="M44 10v28.5c0 4.418-5.373 8-12 8s-12-3.582-12-8 5.373-8 12-8c2.21 0 4.245.43 6 .118V10h6z" fill="%23ff7a00"/></svg>' />
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; display:flex; flex-direction:column; align-items:center; padding:24px; background: #faf7f3; color:#222; }
  h1 { width:100%; max-width:820px; box-sizing:border-box; margin:0 auto 8px; text-align:left; }
  .ver { display:inline-block; margin-left:8px; font-size:12px; color:#666; border:1px solid #ddd; padding:2px 6px; border-radius:999px; background:#fff; }
  p { margin-top:0; color:#444; }
  .keyboard { width:100%; max-width:820px; box-sizing:border-box; display:flex; flex-direction:column; gap:8px; margin-top:18px; 
    /* Responsive sizing vars */
    --cols: 10; /* longest row */
    --gap: 6px; /* horizontal gap */
    --pad: 48px; /* body padding left+right (24*2) */
    --keyRaw: calc((100vw - var(--pad) - (var(--cols) - 1)*var(--gap)) / var(--cols));
    --key: min(52px, var(--keyRaw));
  }
  .row { display:flex; gap: var(--gap); }
  .row.r2 { margin-left: calc(var(--key)/2 + var(--gap)); }
  .row.r3 { margin-left: calc(var(--key) + 2*var(--gap)); }
  .key { width: clamp(34px, var(--key), 52px); height: clamp(34px, var(--key), 52px); display:flex; flex-direction:column; align-items:center; justify-content:center; background: linear-gradient(180deg,#fff 0%,#f0efe8 100%); border:1px solid #ddd; border-radius:8px; box-shadow: 0 6px 18px rgba(30,30,30,0.06); cursor:pointer; user-select:none; }
  .key .k { font-weight:600; }
  .key .n { font-size:11px; color:#666; margin-top:2px; }
  .key:active { transform: translateY(2px) scale(.995); box-shadow:none; }
  .key.active { outline:2px solid #0a66c2; outline-offset:-2px; }
  .key.unavailable { opacity: .45; filter: grayscale(25%); cursor: default; }
  .controls { width:100%; max-width:820px; box-sizing:border-box; margin-top:18px; margin-left:auto; margin-right:auto; }
  label { margin-right:8px; }
  .song { width:100%; max-width:820px; box-sizing:border-box; margin-top:18px; margin-left:auto; margin-right:auto; line-height: 2; }
  .token { display:inline-block; padding:2px 4px; border-radius:6px; margin:2px 3px; background:#fff; border:1px solid #eee; }
  .token .hints { display:block; font-size:10px; color:#777; margin-top:1px; }
  .token.current { outline:2px solid #0a66c2; outline-offset:1px; background:#eef5ff; }
  .token.done { background:#e9f9ee; border-color:#bdebd0; }
  .token .doneStep { color:#3a8f5d; }
  .song-controls { margin-top:10px; }
  .key.guide { outline:2px dashed #ff7a00; outline-offset:-2px; }
  .key.guide-sharp { outline:3px solid #d61f1f; outline-offset:-2px; }
  .song-controls textarea { display:block; width:100%; max-width:820px; height:96px; margin-top:8px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; padding:8px; }
  /* Paste modal */
  .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.35); display:flex; align-items:center; justify-content:center; z-index:1000; }
  .modal { width: min(820px, 94vw); background:#fff; border-radius:10px; box-shadow: 0 20px 60px rgba(0,0,0,0.25); padding:16px; }
  .modal h3 { margin:0 0 8px 0; }
  .modal textarea { width:100%; height:180px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; padding:8px; }
  .modal .actions { display:flex; justify-content:flex-end; gap:8px; margin-top:10px; }
  .token.editing { outline:2px solid #d97706; outline-offset:1px; }
  @media (max-width: 420px) {
    body { padding: 16px; }
    .keyboard { --pad: 32px; }
  }
  
</style>
</head>
<body>
<h1>Keyboard Music <span class="ver">v1.0</span></h1>
<div class="keyboard" id="keyboard"></div>
<div class="controls">
  <label>Nhạc cụ:
    <select id="instrumentSelect">
      <option value="piano" selected>Piano</option>
      <option value="tank-drum">Tank Drum</option>
      <option value="sao">Sáo</option>
      <option value="handpan">Handpan</option>
      <option value="dan-da">Đàn đá</option>
      <option value="dan-tre">Đàn tre</option>
    </select>
  </label>
  <label><input type="checkbox" id="toggleSolfege"> Hiển thị do re mi</label>
  <label style="margin-left:8px;"><input type="checkbox" id="toggleSongMode"> Chơi theo bài hát</label>
  <label style="margin-left:8px;"><input type="checkbox" id="toggleComposer"> Soạn nhạc</label>
</div>

<div class="song-controls">
  <label>Tải bài hát (.txt): <input type="file" id="songFile" accept=".txt" /></label>
  <button id="loadSongBtn">Tải & Hiển thị</button>
  <button id="resetSongBtn">Reset bài</button>
  <label><input type="checkbox" id="toggleShowNotes" checked> Hiển thị nốt nhạc</label>
  <label><input type="checkbox" id="toggleHighlightKeys" checked> Highlight bàn phím</label>
  <button id="pasteSongBtn">Dán & Hiển thị</button>
  <div class="composer-controls" id="composerControls" style="margin-top:8px; display:none;">
    <span id="composerStatus">Chọn một chữ để thêm nốt...</span>
    <button id="composerClearBtn" style="margin-left:8px;">Xóa nốt của chữ</button>
    <input id="composerFileName" placeholder="tên file (vd: bai-hat.txt)" style="margin-left:8px; width:220px;" />
    <button id="composerSaveBtn" style="margin-left:8px;">Lưu bài hát (.txt)</button>
  </div>
</div>
<div class="song" id="songArea"></div>

<!-- Paste modal -->
<div id="pasteModal" class="modal-backdrop" style="display:none;">
  <div class="modal">
    <h3>Dán bài hát</h3>
    <p style="margin-top:0;color:#666;font-size:13px;">Dán nội dung theo định dạng: <code>word{C4}</code> hoặc chỉ lời không có nốt.</p>
    <textarea id="songPasteModal" placeholder="hap{C4}py{C4} ..."></textarea>
    <div class="actions">
      <button id="pasteCancel">Hủy</button>
      <button id="pasteApply">Hiển thị</button>
    </div>
  </div>
  </div>

<script src="./keymap.js"></script>
<script>
// Instruments: add Piano (Tone.js based)
const instruments = {
  'piano': {
    label: 'Piano',
    synth: 'tone-piano',
    pathPrefix: '',
    notes: [] // availability not restricted
  },
  'tank-drum': {
    label: 'Tank Drum',
    synth: 'percussive',
    pathPrefix: 'tank drum/',
    notes: []
  },
  'sao': {
    label: 'Sáo',
    synth: 'flute',
    pathPrefix: 'sao/',
    // Use a bit higher register for sáo
    notes: []
  },
  'handpan': {
    label: 'Handpan',
    synth: 'handpan',
    pathPrefix: 'handpan/',
    notes: []
  },
  'dan-da': {
    label: 'Đàn đá (Lithophone)',
    synth: 'lithophone',
    pathPrefix: 'dan da/',
    notes: []
  },
  'dan-tre': {
    label: 'Đàn tre',
    synth: 'percussive',
    pathPrefix: 'dan tre/',
    notes: []
  }
};
let currentInstrument = 'piano';

// Default keymap used when running from file:// or when fetching keymap.json fails
const DEFAULT_KEYMAP = {
  'tank-drum': {
    q:'C3', w:'D3', e:'E3', r:'F3', t:'G3', y:'A3', u:'B3',
    i:'C4', o:'D4', p:'E4', a:'F4', s:'G4', d:'A4', f:'B4',
    g:'C5', h:'D5', j:'E5', k:'F5', l:'G5',
    z:'A5', x:'C6', c:'D6', v:'E6', b:'F6', n:'G6', m:'A6', ',':'B6'
  },
  'sao': {
    q:'C3', w:'D3', e:'E3', r:'F3', t:'G3', y:'A3', u:'B3',
    i:'C4', o:'D4', p:'E4', a:'F4', s:'G4', d:'A4', f:'B4',
    g:'C5', h:'D5', j:'E5', k:'F5', l:'G5',
    z:'A5', x:'C6', c:'D6', v:'E6', b:'F6', n:'G6', m:'A6', ',':'B6'
  },
  'piano': {
    q:'C3', w:'D3', e:'E3', r:'F3', t:'G3', y:'A3', u:'B3',
    i:'C4', o:'D4', p:'E4', a:'F4', s:'G4', d:'A4', f:'B4',
    g:'C5', h:'D5', j:'E5', k:'F5', l:'G5',
    z:'A5', x:'C6', c:'D6', v:'E6', b:'F6', n:'G6', m:'A6', ',':'B6'
  },
  'handpan': {
    q:'C3', w:'D3', e:'E3', r:'F3', t:'G3', y:'A3', u:'B3',
    i:'C4', o:'D4', p:'E4', a:'F4', s:'G4', d:'A4', f:'B4',
    g:'C5', h:'D5', j:'E5', k:'F5', l:'G5',
    z:'A5', x:'C6', c:'D6', v:'E6', b:'F6', n:'G6', m:'A6', ',':'B6'
  },
  'dan-da': {
    q:'C3', w:'D3', e:'E3', r:'F3', t:'G3', y:'A3', u:'B3',
    i:'C4', o:'D4', p:'E4', a:'F4', s:'G4', d:'A4', f:'B4',
    g:'C5', h:'D5', j:'E5', k:'F5', l:'G5',
    z:'A5', x:'C6', c:'D6', v:'E6', b:'F6', n:'G6', m:'A6', ',':'B6'
  },
  'dan-tre': {
    q:'C3', w:'D3', e:'E3', r:'F3', t:'G3', y:'A3', u:'B3',
    i:'C4', o:'D4', p:'E4', a:'F4', s:'G4', d:'A4', f:'B4',
    g:'C5', h:'D5', j:'E5', k:'F5', l:'G5',
    z:'A5', x:'C6', c:'D6', v:'E6', b:'F6', n:'G6', m:'A6', ',':'B6'
  }
};

const keyRows = [
  ['q','w','e','r','t','y','u','i','o','p'],
  ['a','s','d','f','g','h','j','k','l'],
  ['z','x','c','v','b','n','m',',']
];
const keyOrderFlat = keyRows.flat();
const keyMap = ['z','x','c','v','b','n','m',',']; // legacy note order for quick mapping if needed
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const buffersByInstrument = {}; // instrument -> { name -> AudioBuffer|undefined }
let keymapJson = {}; // loaded from keymap.json
let pressedKeys = new Set();
let shiftHeld = false;

// Song state
let songTokens = []; // [{text: string, notes: ["C4",...], doneSteps: number}]
let songPos = 0; // index in songTokens
let showSongNotes = true;
let highlightKeyboardGuide = true;
let showSolfege = false;
let songMode = false;
let composerMode = false;
let composerSelectedIndex = null; // selected token index for composing

function getCurrentMap(inst = currentInstrument) {
  const fromFile = (keymapJson && keymapJson[inst]) || null;
  const fromDefault = (DEFAULT_KEYMAP && DEFAULT_KEYMAP[inst]) || null;
  return fromFile || fromDefault || {};
}

function toSharpIfNeeded(name, useSharp) {
  if (!useSharp || !name) return name;
  const m = name.match(/^([A-G])(#|b)?(\d)$/);
  if (!m) return name;
  const base = m[1];
  const accidental = m[2] || '';
  const oct = m[3];
  // Only sharpify for F,G,A,C,D when no existing accidental
  const eligible = { F:1, G:1, A:1, C:1, D:1 };
  if (!eligible[base] || accidental) return name;
  // Edge case for E and B are excluded by eligible
  return base + '#' + oct;
}

// Convert note name to solfege with octave (e.g., C4 -> "do 4", F#3 -> "fa# 3")
function noteToSolfege(name) {
  if (!name) return '-';
  const m = name.match(/^([A-G])(#|b)?(\d)$/);
  if (!m) return name;
  const base = m[1];
  const acc = m[2] || '';
  const oct = m[3];
  const map = { C:'do', D:'re', E:'mi', F:'fa', G:'sol', A:'la', B:'si' };
  const syl = map[base] || base.toLowerCase();
  const accTxt = acc === '#' ? '#' : (acc === 'b' ? 'b' : '');
  return syl + accTxt + ' ' + oct;
}

function formatKeyLabel(note) {
  const n = toSharpIfNeeded(note, shiftHeld);
  if (showSolfege) return noteToSolfege(n);
  return n || '-';
}

function ensureAudioContext() {
  if (audioCtx.state === 'suspended') {
    audioCtx.resume().catch(()=>{});
  }
}

function noteToFreq(n) {
  // Parse like C#4, Db4, etc.
  const A4 = 440;
  const map = { C:0, 'C#':1, Db:1, D:2, 'D#':3, Eb:3, E:4, F:5, 'F#':6, Gb:6, G:7, 'G#':8, Ab:8, A:9, 'A#':10, Bb:10, B:11 };
  const m = n.match(/^([A-G](?:#|b)?)(\d)$/);
  if (!m) return 440;
  const [, pc, octStr] = m;
  const octave = parseInt(octStr,10);
  const semitone = map[pc];
  const midi = (octave + 1) * 12 + semitone; // MIDI note number
  const midiA4 = 69;
  return A4 * Math.pow(2, (midi - midiA4) / 12);
}

// --- Flute (Sáo) sustain helpers ---
function startFluteSustain(note) {
  const freq = noteToFreq(note);
  const osc = audioCtx.createOscillator();
  osc.type = 'sine';
  osc.frequency.value = freq;
  const lfo = audioCtx.createOscillator();
  const lfoGain = audioCtx.createGain();
  lfo.frequency.value = 5; // Hz
  lfoGain.gain.value = 10; // cents
  lfo.connect(lfoGain).connect(osc.detune);
  const gain = audioCtx.createGain();
  const now = audioCtx.currentTime;
  gain.gain.setValueAtTime(0.0001, now);
  gain.gain.exponentialRampToValueAtTime(0.55, now + 0.06); // attack
  osc.connect(gain).connect(audioCtx.destination);
  osc.start();
  lfo.start();
  let stopped = false;
  return function stop() {
    if (stopped) return; stopped = true;
    const t = audioCtx.currentTime;
    try {
      gain.gain.cancelScheduledValues(t);
      gain.gain.setValueAtTime(gain.gain.value, t);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);
    } catch(_) {}
    try { osc.stop(t + 0.14); } catch(_) {}
    try { lfo.stop(t + 0.14); } catch(_) {}
  };
}

async function loadSamplesForInstrument(instKey) {
  const inst = instruments[instKey];
  const bufs = buffersByInstrument[instKey] || (buffersByInstrument[instKey] = {});
  for (let i = 0; i < inst.notes.length; i++) {
    const name = inst.notes[i];
    const path = inst.pathPrefix + name + '.wav';
    try {
      const res = await fetch(path);
      if (!res.ok) throw new Error('Missing sample');
      const ab = await res.arrayBuffer();
      const buf = await audioCtx.decodeAudioData(ab);
      bufs[name] = buf;
    } catch (e) {
      bufs[name] = undefined; // fallback to synth
    }
  }
}

async function loadKeymap() {
  // Prefer shared JS keymap when available; otherwise fall back to DEFAULT_KEYMAP
  if (window && window.SHARED_KEYMAP) {
    const shared = window.SHARED_KEYMAP;
    keymapJson = {
      'piano': shared,
      'tank-drum': shared,
      'sao': shared,
      'handpan': shared,
      'dan-da': shared,
      'dan-tre': shared
    };
    return;
  }
  keymapJson = DEFAULT_KEYMAP;
}

function makeKeyButton(k, mappedNote, available) {
  const btn = document.createElement('div');
  btn.className = 'key';
  btn.setAttribute('data-key', k);
  const labelNote = toSharpIfNeeded(mappedNote, shiftHeld);
  btn.innerHTML = `<div class="k">${k.toUpperCase()}</div><div class="n">${formatKeyLabel(mappedNote)}</div>`;
  if (!available && mappedNote) btn.classList.add('unavailable');
  btn.addEventListener('pointerdown', ()=> {
    ensureAudioContext();
    btn.classList.add('active');
    const playName = toSharpIfNeeded(mappedNote, shiftHeld);
    if (playName && available) {
      if (currentInstrument === 'piano' && window.tonePiano) {
        // Song guidance advances only in song mode
        if (songMode) handleNotePlayed(playName);
        window.tonePiano.attack(playName);
        btn.dataset.activeNote = playName;
      } else if (currentInstrument === 'sao') {
        // Sáo sustain while holding
        if (songMode) handleNotePlayed(playName);
        btn._fluteStop = startFluteSustain(playName);
      } else {
        playNote(playName);
      }
    }
  });
  btn.addEventListener('pointerup', ()=> {
    btn.classList.remove('active');
    if (currentInstrument === 'piano' && window.tonePiano && btn.dataset.activeNote) {
      window.tonePiano.release(btn.dataset.activeNote);
      delete btn.dataset.activeNote;
    } else if (currentInstrument === 'sao' && btn._fluteStop) {
      try { btn._fluteStop(); } catch(_){}
      delete btn._fluteStop;
    }
  });
  btn.addEventListener('pointerleave', ()=> {
    btn.classList.remove('active');
    if (currentInstrument === 'piano' && window.tonePiano && btn.dataset.activeNote) {
      window.tonePiano.release(btn.dataset.activeNote);
      delete btn.dataset.activeNote;
    } else if (currentInstrument === 'sao' && btn._fluteStop) {
      try { btn._fluteStop(); } catch(_){ }
      delete btn._fluteStop;
    }
  });
  btn.addEventListener('pointercancel', ()=> {
    btn.classList.remove('active');
    if (currentInstrument === 'piano' && window.tonePiano && btn.dataset.activeNote) {
      window.tonePiano.release(btn.dataset.activeNote);
      delete btn.dataset.activeNote;
    } else if (currentInstrument === 'sao' && btn._fluteStop) {
      try { btn._fluteStop(); } catch(_){ }
      delete btn._fluteStop;
    }
  });
  return btn;
}

function playNote(name) {
  // Validate against song if any
  if (songMode) handleNotePlayed(name);
  if (currentInstrument === 'piano' && window.tonePiano) {
    window.tonePiano.play(name);
    return;
  }
  const bufs = buffersByInstrument[currentInstrument] || {};
  const buf = bufs[name];
  (window._playing = window._playing || []);
  if (buf) {
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    const gain = audioCtx.createGain();
    gain.gain.value = 1.0;
    src.connect(gain).connect(audioCtx.destination);
    src.start();
    window._playing.push({ stop: () => { try { src.stop(); } catch(_){} }, node: src });
    src.onended = ()=> {
      const idx = window._playing.findIndex(o=>o.node===src);
      if (idx>=0) window._playing.splice(idx,1);
    };
    return;
  }
  const freq = noteToFreq(name);
  const synthType = instruments[currentInstrument].synth;
  if (synthType === 'percussive') {
    // Tank drum: percussive hit with longer tail (~1.8s)
    const osc1 = audioCtx.createOscillator();
    const osc2 = audioCtx.createOscillator();
    osc1.type = 'sine';
    osc2.type = 'sine';
    osc1.frequency.value = freq;
    osc2.frequency.value = freq * 2.01;
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = freq * 1.4;
    filter.Q.value = 7;
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(0.9, now + 0.008);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 1.8);
    osc1.connect(filter);
    osc2.connect(filter);
    filter.connect(gain).connect(audioCtx.destination);
    osc1.start();
    osc2.start();
    const stopAt = now + 1.85;
    osc1.stop(stopAt);
    osc2.stop(stopAt);
    const playingObj = { stop: () => { try { osc1.stop(); } catch(_){} try { osc2.stop(); } catch(_){} }, node: osc1 };
    window._playing.push(playingObj);
    osc1.onended = () => {
      const idx = window._playing.indexOf(playingObj);
      if (idx>=0) window._playing.splice(idx,1);
    };
  } else if (synthType === 'handpan') {
    // Handpan: soft attack, rich overtones, long decay (~3.2s)
    const oscFund = audioCtx.createOscillator();
    const oscOver = audioCtx.createOscillator();
    oscFund.type = 'sine';
    oscOver.type = 'triangle';
    oscFund.frequency.value = freq;
    oscOver.frequency.value = freq * 2.02;
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = freq * 1.2;
    filter.Q.value = 8;
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.linearRampToValueAtTime(0.7, now + 0.04); // softer attack
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 3.2);
    oscFund.connect(filter);
    oscOver.connect(filter);
    filter.connect(gain).connect(audioCtx.destination);
    oscFund.start();
    oscOver.start();
    const stopAt = now + 3.25;
    oscFund.stop(stopAt);
    oscOver.stop(stopAt);
    const playingObj = { stop: () => { try { oscFund.stop(); } catch(_){} try { oscOver.stop(); } catch(_){} }, node: oscFund };
    window._playing.push(playingObj);
    oscFund.onended = () => {
      const idx = window._playing.indexOf(playingObj);
      if (idx>=0) window._playing.splice(idx,1);
    };
  } else if (synthType === 'lithophone') {
    // Lithophone (Đàn đá): bright mallet, glassy tone, medium-long decay (~2.4s)
    const osc = audioCtx.createOscillator();
    const oscH = audioCtx.createOscillator();
    osc.type = 'sine';
    oscH.type = 'square';
    osc.frequency.value = freq;
    oscH.frequency.value = freq * 3.0;
    const hp = audioCtx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 200;
    const bp = audioCtx.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.value = freq * 1.1;
    bp.Q.value = 10;
    const gain = audioCtx.createGain();
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(0.85, now + 0.005);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 2.4);
    osc.connect(hp).connect(bp);
    oscH.connect(bp);
    bp.connect(gain).connect(audioCtx.destination);
    osc.start();
    oscH.start();
    const stopAt = now + 2.45;
    osc.stop(stopAt);
    oscH.stop(stopAt);
    const playingObj = { stop: () => { try { osc.stop(); } catch(_){} try { oscH.stop(); } catch(_){} }, node: osc };
    window._playing.push(playingObj);
    osc.onended = () => {
      const idx = window._playing.indexOf(playingObj);
      if (idx>=0) window._playing.splice(idx,1);
    };
  } else {
    // Sáo: longer sustain (~2.2s) with gentle vibrato
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const lfo = audioCtx.createOscillator();
    const lfoGain = audioCtx.createGain();
    lfo.frequency.value = 5; // 5 Hz vibrato
    lfoGain.gain.value = 10; // cents
    lfo.connect(lfoGain).connect(osc.detune);
    const gain = audioCtx.createGain();
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(0.55, now + 0.08);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 2.2);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start();
    lfo.start();
    const stopAt = now + 2.25;
    osc.stop(stopAt);
    lfo.stop(stopAt);
    const playingObj = { stop: () => { try { osc.stop(); } catch(_){} try { lfo.stop(); } catch(_){} }, node: osc };
    window._playing.push(playingObj);
    osc.onended = () => {
      const idx = window._playing.indexOf(playingObj);
      if (idx>=0) window._playing.splice(idx,1);
    };
  }
}

function stopAll() {
  if (!window._playing) return;
  window._playing.forEach(o=>{ try{ o.stop(); } catch(e){} });
  window._playing = [];
  if (currentInstrument === 'piano' && window.tonePiano) {
    window.tonePiano.stopAll();
  }
  if (window._fluteActiveByKey) {
    for (const k in window._fluteActiveByKey) {
      try { window._fluteActiveByKey[k](); } catch(_){ }
      delete window._fluteActiveByKey[k];
    }
  }
}

function updateSongModeUI() {
  const sc = document.querySelector('.song-controls');
  const sa = document.getElementById('songArea');
  if (!sc || !sa) return;
  const show = songMode || composerMode;
  sc.style.display = show ? '' : 'none';
  sa.style.display = show ? '' : 'none';
  if (!songMode) {
    // Clear any guide highlights when hiding
    document.querySelectorAll('.key.guide').forEach(el=> el.classList.remove('guide'));
    document.querySelectorAll('.key.guide-sharp').forEach(el=> el.classList.remove('guide-sharp'));
  } else {
    updateKeyboardGuideHighlight();
  }
  // Composer controls visibility
  const cc = document.getElementById('composerControls');
  if (cc) cc.style.display = composerMode ? '' : 'none';
}

function rebuildUI() {
  const kb = document.getElementById('keyboard');
  kb.innerHTML = '';
  const inst = instruments[currentInstrument];
  const currentMap = getCurrentMap();
  keyRows.forEach((rowKeys, idx)=>{
    const row = document.createElement('div');
    row.className = 'row ' + (idx===0?'r1':idx===1?'r2':'r3');
    rowKeys.forEach(k=>{
      const note = currentMap[k] || '';
      const available = !!note && (inst.notes.length === 0 || inst.notes.includes(note));
      row.appendChild(makeKeyButton(k, note, available));
    });
    kb.appendChild(row);
  });
}

function refreshLabelsForShift() {
  const currentMap = getCurrentMap();
  for (const k of keyRows.flat()) {
    const note = currentMap[k] || '';
    const el = document.querySelector(`[data-key="${CSS.escape(k)}"] .n`);
    if (el) el.textContent = formatKeyLabel(note);
  }
}

// --- Song parsing and rendering ---
function parseSong(text) {
  const lines = text.split(/\r?\n/);
  const seq = [];
  const tokenRe = /([^{}\s]+|\[[^\]]+\])((?:\{[A-G](?:#|b)?\d\})+)/g;
  for (let li = 0; li < lines.length; li++) {
    const line = lines[li];
    let m;
    let matched = false;
    tokenRe.lastIndex = 0;
    while ((m = tokenRe.exec(line)) !== null) {
      matched = true;
      const textPart = m[1];
      const notesPart = m[2];
      const noteMatches = Array.from(notesPart.matchAll(/\{([A-G](?:#|b)?\d)\}/g)).map(x=>x[1]);
      seq.push({ text: textPart, notes: noteMatches, doneSteps: 0 });
    }
    if (!matched && line.trim()) {
      const words = line.trim().split(/\s+/);
      for (const w of words) seq.push({ text: w, notes: [], doneSteps: 0 });
    }
    if (li < lines.length - 1) seq.push({ text: '\n', notes: [], doneSteps: 0 });
  }
  return seq;
}

function renderSong() {
  const area = document.getElementById('songArea');
  area.innerHTML = '';
  let line = document.createElement('div');
  area.appendChild(line);
  for (let i = 0; i < songTokens.length; i++) {
    const tok = songTokens[i];
    if (tok.text === '\n') { line = document.createElement('div'); area.appendChild(line); continue; }
    const span = document.createElement('span');
    span.className = 'token';
    if (i === songPos) span.classList.add('current');
    if (composerMode && i === composerSelectedIndex) span.classList.add('editing');
    span.textContent = tok.text;
    const hints = document.createElement('span');
    hints.className = 'hints';
    if (showSongNotes && tok.notes && tok.notes.length) {
      hints.textContent = tok.notes.join(' ');
    } else {
      hints.textContent = '';
    }
    span.appendChild(hints);
    span.setAttribute('data-index', String(i));
    span.style.cursor = composerMode ? 'pointer' : 'default';
    span.addEventListener('click', ()=>{
      if (!composerMode) return;
      composerSelectedIndex = i;
      updateComposerStatus();
      renderSong();
    });
    line.appendChild(span);
  }
  updateKeyboardGuideHighlight();
}

function updateSongHighlight() {
  const tokens = document.querySelectorAll('#songArea .token');
  tokens.forEach(el=> el.classList.remove('current','done'));
  // Find next visible token (skip newline placeholders)
  let visIdx = songPos;
  while (visIdx < songTokens.length && songTokens[visIdx].text === '\n') visIdx++;
  if (visIdx < songTokens.length) {
    const el = document.querySelector(`#songArea .token[data-index="${visIdx}"]`);
    if (el) el.classList.add('current');
  }
  songTokens.forEach((t, idx)=>{
    if (t.notes.length>0 && t.doneSteps >= t.notes.length) {
      const el = document.querySelector(`#songArea .token[data-index="${idx}"]`);
      if (el) el.classList.add('done');
    }
    if (showSongNotes) {
      const el = document.querySelector(`#songArea .token[data-index="${idx}"] .hints`);
      if (el) {
        if (t.notes.length) el.textContent = t.notes.join(' ');
        else el.textContent = '';
      }
    }
  });
  updateKeyboardGuideHighlight();
}

function handleNotePlayed(note) {
  if (!songTokens.length) return;
  // Skip non-note tokens
  while (songPos < songTokens.length && songTokens[songPos].notes.length === 0) songPos++;
  if (songPos >= songTokens.length) return;
  const cur = songTokens[songPos];
  const expected = cur.notes[cur.doneSteps];
  if (!expected) { songPos++; updateSongHighlight(); return; }
  if (note === expected) {
    cur.doneSteps++;
    if (cur.doneSteps >= cur.notes.length) {
      songPos++;
      // Immediately skip through newline tokens so next line's first word is highlighted
      while (songPos < songTokens.length && songTokens[songPos].text === '\n') songPos++;
    }
    updateSongHighlight();
  }
}

function updateKeyboardGuideHighlight() {
  // Clear previous guide highlights
  document.querySelectorAll('.key.guide').forEach(el=> el.classList.remove('guide'));
  document.querySelectorAll('.key.guide-sharp').forEach(el=> el.classList.remove('guide-sharp'));
  if (!songMode) return;
  if (!highlightKeyboardGuide) return;
  if (!songTokens.length) return;
  // Find next token needing a note
  let pos = songPos;
  while (pos < songTokens.length && songTokens[pos].notes.length === 0) pos++;
  if (pos >= songTokens.length) return;
  const cur = songTokens[pos];
  const expected = cur.notes[cur.doneSteps];
  if (!expected) return;
  const isSharp = expected.includes('#');
  // Find keys that map to expected note for current instrument
  const currentMap = getCurrentMap();
  for (const [k, v] of Object.entries(currentMap)) {
    // Match either direct mapping or sharped form
    if (v === expected || toSharpIfNeeded(v, true) === expected) {
      const keyEl = document.querySelector(`[data-key="${CSS.escape(k)}"]`);
      if (keyEl) keyEl.classList.add(isSharp ? 'guide-sharp' : 'guide');
    }
  }
}

(async ()=>{
  await loadKeymap();
  rebuildUI();
  await loadSamplesForInstrument(currentInstrument);
  console.log('Samples loaded for', currentInstrument);
  // Initialize song mode UI (default hidden)
  updateSongModeUI();
})();

// Safety: stop all sustained sounds on tab hide or window blur
window.addEventListener('blur', stopAll);
document.addEventListener('visibilitychange', ()=>{ if (document.hidden) stopAll(); });

document.getElementById('instrumentSelect').addEventListener('change', async (e)=>{
  currentInstrument = e.target.value;
  rebuildUI();
  if (currentInstrument !== 'piano') {
    await loadSamplesForInstrument(currentInstrument);
  }
  updateKeyboardGuideHighlight();
});

// Paste song handlers (modal)
function showPasteModal(show) {
  const el = document.getElementById('pasteModal');
  if (!el) return;
  el.style.display = show ? '' : 'none';
  if (show) setTimeout(()=>{ const ta = document.getElementById('songPasteModal'); if (ta) ta.focus(); }, 0);
}
document.getElementById('pasteSongBtn').addEventListener('click', ()=>{
  showPasteModal(true);
});
document.getElementById('pasteCancel').addEventListener('click', ()=>{
  showPasteModal(false);
});
document.getElementById('pasteApply').addEventListener('click', ()=>{
  const ta = document.getElementById('songPasteModal');
  const txt = (ta && ta.value || '').trim();
  if (!txt) { showPasteModal(false); return; }
  songTokens = parseSong(txt);
  songPos = 0;
  renderSong();
  updateSongHighlight();
  updateComposerStatus();
  showPasteModal(false);
});

window.addEventListener('keydown', (e)=>{
  const k = e.key.toLowerCase();
  if (k === 'shift') { if (!shiftHeld) { shiftHeld = true; refreshLabelsForShift(); } return; }
  if (pressedKeys.has(k)) return; // avoid repeats until keyup
  pressedKeys.add(k);
  const btn = document.querySelector(`[data-key="${CSS.escape(k)}"]`);
  if (btn) btn.classList.add('active');
  const currentMap = getCurrentMap();
  let name = currentMap[k];
  name = toSharpIfNeeded(name, e.shiftKey || shiftHeld);
  const inst = instruments[currentInstrument];
  const available = !!name && (inst.notes.length === 0 || inst.notes.includes(name));
  if (name && available) {
    ensureAudioContext();
    if (currentInstrument === 'piano' && window.tonePiano) {
      // Song guidance advances only in song mode
      if (songMode) handleNotePlayed(name);
      window.tonePiano.attack(name);
      // store mapping for release
      (window._pianoActiveByKey = window._pianoActiveByKey || {})[k] = name;
    } else if (currentInstrument === 'sao') {
      // Sáo sustain while key is held
      if (songMode) handleNotePlayed(name);
      const stop = startFluteSustain(name);
      (window._fluteActiveByKey = window._fluteActiveByKey || {})[k] = stop;
      if (btn) btn._fluteStop = stop;
    } else {
      playNote(name);
    }
    // Composer capture
    if (composerMode && composerSelectedIndex !== null) {
      const tok = songTokens[composerSelectedIndex];
      if (tok && tok.text !== '\n') {
        tok.notes = tok.notes || [];
        tok.notes.push(name);
        renderSong();
      }
    }
  }
});

window.addEventListener('keyup', (e)=>{
  const k = e.key.toLowerCase();
  if (k === 'shift') { shiftHeld = false; refreshLabelsForShift(); return; }
  pressedKeys.delete(k);
  const btn = document.querySelector(`[data-key="${CSS.escape(k)}"]`);
  if (btn) btn.classList.remove('active');
  if (currentInstrument === 'piano' && window.tonePiano && window._pianoActiveByKey && window._pianoActiveByKey[k]) {
    const note = window._pianoActiveByKey[k];
    window.tonePiano.release(note);
    delete window._pianoActiveByKey[k];
  } else if (currentInstrument === 'sao' && window._fluteActiveByKey && window._fluteActiveByKey[k]) {
    const stop = window._fluteActiveByKey[k];
    try { stop(); } catch(_){ }
    delete window._fluteActiveByKey[k];
  } else if (currentInstrument === 'sao' && btn && btn._fluteStop) {
    // Fallback in case the global map missed this key
    try { btn._fluteStop(); } catch(_){ }
    delete btn._fluteStop;
  }
});

// Song UI handlers
document.getElementById('loadSongBtn').addEventListener('click', async ()=>{
  const inp = document.getElementById('songFile');
  const file = inp.files && inp.files[0];
  if (!file) return;
  const txt = await file.text();
  songTokens = parseSong(txt);
  songPos = 0;
  renderSong();
  updateSongHighlight();
});

document.getElementById('resetSongBtn').addEventListener('click', ()=>{
  songTokens.forEach(t=> t.doneSteps = 0);
  songPos = 0;
  updateSongHighlight();
});

// Toggle handlers
document.getElementById('toggleShowNotes').addEventListener('change', (e)=>{
  showSongNotes = !!e.target.checked;
  renderSong();
  updateSongHighlight();
});
document.getElementById('toggleHighlightKeys').addEventListener('change', (e)=>{
  highlightKeyboardGuide = !!e.target.checked;
  updateKeyboardGuideHighlight();
});
document.getElementById('toggleSolfege').addEventListener('change', (e)=>{
  showSolfege = !!e.target.checked;
  refreshLabelsForShift();
});
document.getElementById('toggleSongMode').addEventListener('change', (e)=>{
  songMode = !!e.target.checked;
  updateSongModeUI();
});
document.getElementById('toggleComposer').addEventListener('change', (e)=>{
  composerMode = !!e.target.checked;
  if (!composerMode) composerSelectedIndex = null;
  updateComposerStatus();
  renderSong();
  updateSongModeUI();
});

function updateComposerStatus() {
  const el = document.getElementById('composerStatus');
  if (!el) return;
  if (!composerMode) { el.textContent = 'Soạn nhạc đang tắt'; return; }
  if (composerSelectedIndex === null) { el.textContent = 'Chọn một chữ để thêm nốt...'; return; }
  const tok = songTokens[composerSelectedIndex];
  if (!tok) { el.textContent = 'Không có chữ được chọn'; return; }
  const notes = (tok.notes && tok.notes.length) ? tok.notes.join(' ') : '(chưa có nốt)';
  el.textContent = `Đang chọn: "${tok.text}"  |  Nốt: ${notes}`;
}

document.getElementById('composerClearBtn').addEventListener('click', ()=>{
  if (!composerMode || composerSelectedIndex === null) return;
  const tok = songTokens[composerSelectedIndex];
  if (!tok || tok.text === '\n') return;
  tok.notes = [];
  renderSong();
  updateComposerStatus();
});

function serializeSongToTxt() {
  const parts = [];
  for (let i = 0; i < songTokens.length; i++) {
    const tok = songTokens[i];
    if (tok.text === '\n') { parts.push('\n'); continue; }
    const notes = (tok.notes || []).map(n=>`{${n}}`).join('');
    parts.push(tok.text + notes + ' ');
  }
  return parts.join('').replace(/[ ]+\n/g, '\n').trim();
}

document.getElementById('composerSaveBtn').addEventListener('click', ()=>{
  const txt = serializeSongToTxt();
  const nameInput = document.getElementById('composerFileName');
  let filename = (nameInput && nameInput.value || '').trim();
  if (!filename) filename = 'bai-hat.txt';
  if (!/\.txt$/i.test(filename)) filename += '.txt';
  const blob = new Blob([txt], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});
</script>
<!-- Tone.js and piano layer -->
<script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
<script src="./tone.js"></script>
</body>
</html>
