<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Keyboard Music</title>
<link rel="icon" href='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="32" fill="%23fff3e6"/><path d="M44 10v28.5c0 4.418-5.373 8-12 8s-12-3.582-12-8 5.373-8 12-8c2.21 0 4.245.43 6 .118V10h6z" fill="%23ff7a00"/></svg>' />
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; display:flex; flex-direction:column; align-items:center; padding:24px; background: #faf7f3; color:#222; }
  h1 { width:100%; max-width:820px; box-sizing:border-box; margin:0 auto 8px; text-align:left; }
  .ver { display:inline-block; margin-left:8px; font-size:12px; color:#666; border:1px solid #ddd; padding:2px 6px; border-radius:999px; background:#fff; }
  p { margin-top:0; color:#444; }
  .keyboard { width:100%; max-width:820px; box-sizing:border-box; display:flex; flex-direction:column; gap:8px; margin:18px auto 0;
    /* Responsive sizing based on container width (not viewport) */
    --cols: 10; /* longest row */
    --gap: 6px; /* horizontal gap */
    --keyRaw: calc((100% - (var(--cols) - 1)*var(--gap)) / var(--cols));
    --key: min(52px, var(--keyRaw));
  }
  .row { display:flex; gap: var(--gap); justify-content: flex-start; }
  /* Keyboard wrapper with side buttons */
  .kbd-wrap { width:100%; box-sizing:border-box; display:flex; align-items:center; justify-content:center; gap:10px; }
  .oct-btn { width:38px; height:52px; border-radius:8px; border:1px solid #ddd; background:#fff; cursor:pointer; box-shadow: 0 6px 18px rgba(30,30,30,0.06); }
  .oct-btn:active { transform: translateY(2px) scale(.995); box-shadow:none; }
  /* Keep full-size keys and let keyboard width match content so right button hugs keys */
  .kbd-wrap .keyboard { margin: 18px 0 0; width: max-content; --key: 52px; }
  /* Remove trailing row spacer inside wrapper so right button hugs the last key */
  .kbd-wrap .row::after { display: none; }
  /* Stagger rows using flex spacer to retain centering */
  .row.r2::before { content: ""; display:block; width: calc(var(--key)/2 - var(--gap)/2); flex: 0 0 auto; }
  .row.r3::before { content: ""; display:block; width: var(--key); flex: 0 0 auto; }
  /* Trailing spacer to make each row total width equal to full columns, avoiding right drift */
  .row::after { content: ""; display:block; flex: 0 0 auto; width: calc((var(--cols) - var(--len, 0)) * (var(--key) + var(--gap)) - var(--gap)); }
  .key { width: clamp(34px, var(--key), 52px); height: clamp(34px, var(--key), 52px); display:flex; flex-direction:column; align-items:center; justify-content:center; background: linear-gradient(180deg,#fff 0%,#f0efe8 100%); border:1px solid #ddd; border-radius:8px; box-shadow: 0 6px 18px rgba(30,30,30,0.06); cursor:pointer; user-select:none; }
  .key .k { font-weight:600; }
  .key .n { font-size:11px; color:#666; margin-top:2px; }
  .key:active { transform: translateY(2px) scale(.995); box-shadow:none; }
  .key.active { outline:2px solid #0a66c2; outline-offset:-2px; }
  .key.unavailable { opacity: .45; filter: grayscale(25%); cursor: default; }
  /* Sharp keys: slightly darker gray, keep normal text colors for readability */
  .key.sharp { background: linear-gradient(180deg,#ececec,#d9d9d9); color:#222; border-color:#c7c7c7; }
  .key.sharp .n { color:#666; }
  /* Guide highlighting */
  .key.guide { outline:2px dashed #0a66c2; outline-offset:-2px; }
  .key.guide-sharp { outline:2px dashed #e58b0a; outline-offset:-2px; background-image: repeating-linear-gradient(45deg, rgba(229,139,10,0.06) 0 6px, transparent 6px 12px); }
  .key.guide-shift { outline:2px dashed #d93c65; outline-offset:-2px; background-image: repeating-linear-gradient(45deg, rgba(217,60,101,0.06) 0 6px, transparent 6px 12px); }
  /* Right-hand groups coloring */
  .key.rh-r2 { background: linear-gradient(180deg,#f8fbff 0%, #eef5ff 100%); border-color:#d8e7fb; }
  .key.rh-r3 { background: linear-gradient(180deg,#fff9f3 0%, #fff2e6 100%); border-color:#f5dec2; }
  /* Middle-row group color for A..J (yellow tone to differ from sharps) */
  .key.rh-mid { background: linear-gradient(180deg,#fff7e6 0%, #ffe6b3 100%); border-color:#f2d59a; }
  /* Ensure sharp styling wins over group colors when both classes exist */
  .key.sharp { background: linear-gradient(180deg,#ececec,#d9d9d9); border-color:#c7c7c7; }
  .controls { width:100%; max-width:820px; box-sizing:border-box; margin-top:18px; margin-left:auto; margin-right:auto; }
  label { margin-right:8px; }
  .song { width:100%; max-width:820px; box-sizing:border-box; margin-top:18px; margin-left:auto; margin-right:auto; line-height: 2; }
  .song.scrollable { max-height: 50vh; overflow-y: auto; }
  .token { display:inline-block; padding:2px 4px; border-radius:6px; margin:2px 3px; background:#fff; border:1px solid #eee; }
  .token .hints { display:block; font-size:10px; color:#777; margin-top:1px; }
  .token.current { outline:2px solid #0a66c2; outline-offset:1px; background:#eef5ff; }
  .token.done { background:#e9f9ee; border-color:#bdebd0; }
  .token .doneStep { color:#3a8f5d; }
  .song-controls { margin-top:10px; }
  .key.guide { outline:2px dashed #ff7a00; outline-offset:-2px; }
  .key.guide-sharp { outline:3px solid #d61f1f; outline-offset:-2px; }
  .song-controls textarea { display:block; width:100%; max-width:820px; height:96px; margin-top:8px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; padding:8px; }
  /* Paste modal */
  .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.35); display:flex; align-items:center; justify-content:center; z-index:1000; }
  .modal { width: min(820px, 94vw); background:#fff; border-radius:10px; box-shadow: 0 20px 60px rgba(0,0,0,0.25); padding:16px; }
  .modal h3 { margin:0 0 8px 0; }
  .modal textarea { width:100%; height:180px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; padding:8px; }
  .modal .actions { display:flex; justify-content:flex-end; gap:8px; margin-top:10px; }
  .token.editing { outline:2px solid #d97706; outline-offset:1px; }
  @media (max-width: 420px) {
    body { padding: 16px; }
  }
  .composer-staff { width:100%; max-width:820px; box-sizing:border-box; margin:16px auto 0; }
  .composer-staff .staff { width:100%; height:auto; display:block; background:#fff; border:1px solid #e8e8e8; border-radius:10px; }
  .composer-staff .staff-line { stroke:#222; stroke-width:1.2; }
  .composer-staff .barline { stroke:#444; stroke-width:1.5; }
  .composer-staff .notehead { fill:#111; }
  .composer-staff .note.active .notehead { fill:#0a66c2; }
  .composer-staff .note.active .note-label { fill:#0a66c2; font-weight: 700; }
  .composer-staff .ledger { stroke:#222; stroke-width:1.1; }
  .composer-staff .note { cursor:pointer; }
  .composer-staff .note-label { font: 14px/1.2 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; fill:#333; }
</style>
</head>
<body>
<h1>Keyboard Music <span class="ver">v2.3</span></h1>
<!-- Song area fixed on top -->
<div id="songTop" class="song-top" style="display:none;">
  <div class="song" id="songArea"></div>
  <style>
    .song-top { 
      margin:8px 0 12px; 
      background:#fff; 
      border:1px solid #eee; 
      border-radius:12px; 
      padding:8px 10px; 
      max-height: 240px; 
      overflow-y: auto; 
      box-shadow: 0 8px 24px rgba(0,0,0,0.04);
    }
    .song {
      overflow: visible !important;
    }
    .song.scrollable {
      overflow-y: visible !important;
    }
  </style>
</div>
<!-- Composer staff is now always visible and placed above the keyboard -->
<div id="composerStaff" class="composer-staff" style="display:none;">
  <svg id="composerStaffSvg" class="staff" viewBox="0 0 1600 220" preserveAspectRatio="xMidYMid meet"></svg>
</div>
<div class="kbd-wrap">
  <button id="octaveDownBtn" class="oct-btn" title="Giảm 1 quãng">◄</button>
  <div class="keyboard" id="keyboard"></div>
  <button id="octaveUpBtn" class="oct-btn" title="Tăng 1 quãng">►</button>
</div>
<div class="controls">
  <label>Nhạc cụ:
    <select id="instrumentSelect">
      <option value="piano" selected>Piano</option>
      <option value="guitar">Guitar</option>
      <option value="tank-drum">Tank Drum</option>
      <option value="sao">Sáo</option>
      <option value="marimba">Marimba</option>
      <option value="handpan">Handpan</option>
      <option value="dan-da">Đàn đá</option>
      <option value="dan-bau">Đàn bầu</option>
    </select>
  </label>
  <label><input type="checkbox" id="toggleSolfege"> Hiển thị do re mi</label>
  <label style="margin-left:8px;"><input type="checkbox" id="toggleSongMode"> Chơi theo bài hát</label>
  <label style="margin-left:8px;"><input type="checkbox" id="toggleComposer"> Soạn nhạc</label>
  <label style="margin-left:8px;"><input type="checkbox" id="toggleStaff"> Hiện khuông nhạc</label>
</div>

<div class="song-controls">
  <label>Tải bài hát (.txt): <input type="file" id="songFile" accept=".txt" /></label>
  <button id="loadSongBtn">Tải & Hiển thị</button>
  <button id="resetSongBtn">Reset bài</button>
  <label><input type="checkbox" id="toggleShowNotes" checked> Hiển thị nốt nhạc</label>
  <label><input type="checkbox" id="toggleHighlightKeys" checked> Highlight bàn phím</label>
  <button id="pasteSongBtn">Dán & Hiển thị</button>
  <!-- GitHub songs list will appear here when song mode is enabled -->
  <div id="githubSongList" style="margin-top:8px; display:none; font-size:13px;"></div>
  <div class="composer-controls" id="composerControls" style="margin-top:8px; display:none;">
    <span id="composerStatus">Chọn một chữ để thêm nốt...</span>
    <button id="composerClearBtn" style="margin-left:8px;">Xóa nốt của chữ</button>
    <button id="composerSaveBtn" style="margin-left:8px;">Lưu bài hát (.txt)</button>
  </div>
</div>

<!-- Paste modal -->
<div id="pasteModal" class="modal-backdrop" style="display:none;">
  <div class="modal">
    <h3>Dán bài hát</h3>
    <p style="margin-top:0;color:#666;font-size:13px;">Dán nội dung theo định dạng: <code>word{C4}</code> hoặc chỉ lời không có nốt.</p>
    <textarea id="songPasteModal" placeholder="hap{C4}py{C4} ..."></textarea>
    <div class="actions">
      <button id="pasteCancel">Hủy</button>
      <button id="pasteApply">Hiển thị</button>
    </div>
  </div>
  </div>

<script src="./keymap.js"></script>
<script>
// Instruments: add Piano (Tone.js based)
const instruments = {
  'piano': {
    label: 'Piano',
    synth: 'tone-piano',
    pathPrefix: '',
    notes: [] // availability not restricted
  },
  'guitar': {
    label: 'Guitar',
    synth: 'guitar',
    pathPrefix: '',
    notes: []
  },
  'tank-drum': {
    label: 'Tank Drum',
    synth: 'percussive',
    pathPrefix: 'tank drum/',
    notes: []
  },
  'sao': {
    label: 'Sáo',
    synth: 'flute',
    pathPrefix: 'sao/',
    // Use a bit higher register for sáo
    notes: []
  },
  'handpan': {
    label: 'Handpan',
    synth: 'handpan',
    pathPrefix: 'handpan/',
    notes: []
  },
  'marimba': {
    label: 'Marimba',
    synth: 'marimba',
    pathPrefix: '',
    notes: []
  },
  'dan-da': {
    label: 'Đàn đá (Lithophone)',
    synth: 'lithophone',
    pathPrefix: 'dan da/',
    notes: []
  },
  'dan-bau': {
    label: 'Đàn bầu',
    synth: 'danbau',
    pathPrefix: '',
    notes: []
  }
};
let currentInstrument = 'piano';

// Default keymap used when running from file:// or when fetching keymap.json fails
const DEFAULT_KEYMAP = {
  'guitar': {
    // Sharps on top row
    w:'C#4', e:'D#4', t:'F#4', y:'G#4', u:'A#4', o:'C#5', p:'D#5',
    // Naturals ZXCVASDFGHJKLBNM,. -> F3..B5
    z:'F3', x:'G3', c:'A3', v:'B3',
    a:'C4', s:'D4', d:'E4', f:'F4', g:'G4', h:'A4', j:'B4', k:'C5', l:'D5',
    b:'E5', n:'F5', m:'G5', ',':'A5', '.':'B5'
  },
  'tank-drum': {
    w:'C#4', e:'D#4', t:'F#4', y:'G#4', u:'A#4', o:'C#5', p:'D#5',
    z:'F3', x:'G3', c:'A3', v:'B3',
    a:'C4', s:'D4', d:'E4', f:'F4', g:'G4', h:'A4', j:'B4', k:'C5', l:'D5',
    b:'E5', n:'F5', m:'G5', ',':'A5', '.':'B5'
  },
  'marimba': {
    w:'C#4', e:'D#4', t:'F#4', y:'G#4', u:'A#4', o:'C#5', p:'D#5',
    z:'F3', x:'G3', c:'A3', v:'B3',
    a:'C4', s:'D4', d:'E4', f:'F4', g:'G4', h:'A4', j:'B4', k:'C5', l:'D5',
    b:'E5', n:'F5', m:'G5', ',':'A5', '.':'B5'
  },
  'sao': {
    w:'C#4', e:'D#4', t:'F#4', y:'G#4', u:'A#4', o:'C#5', p:'D#5',
    z:'F3', x:'G3', c:'A3', v:'B3',
    a:'C4', s:'D4', d:'E4', f:'F4', g:'G4', h:'A4', j:'B4', k:'C5', l:'D5',
    b:'E5', n:'F5', m:'G5', ',':'A5', '.':'B5'
  },
  'piano': {
    w:'C#4', e:'D#4', t:'F#4', y:'G#4', u:'A#4', o:'C#5', p:'D#5',
    z:'F3', x:'G3', c:'A3', v:'B3',
    a:'C4', s:'D4', d:'E4', f:'F4', g:'G4', h:'A4', j:'B4', k:'C5', l:'D5',
    b:'E5', n:'F5', m:'G5', ',':'A5', '.':'B5'
  },
  'handpan': {
    w:'C#4', e:'D#4', t:'F#4', y:'G#4', u:'A#4', o:'C#5', p:'D#5',
    z:'F3', x:'G3', c:'A3', v:'B3',
    a:'C4', s:'D4', d:'E4', f:'F4', g:'G4', h:'A4', j:'B4', k:'C5', l:'D5',
    b:'E5', n:'F5', m:'G5', ',':'A5', '.':'B5'
  },
  'dan-da': {
    w:'C#4', e:'D#4', t:'F#4', y:'G#4', u:'A#4', o:'C#5', p:'D#5',
    z:'F3', x:'G3', c:'A3', v:'B3',
    a:'C4', s:'D4', d:'E4', f:'F4', g:'G4', h:'A4', j:'B4', k:'C5', l:'D5',
    b:'E5', n:'F5', m:'G5', ',':'A5', '.':'B5'
  },
  'dan-bau': {
    w:'C#4', e:'D#4', t:'F#4', y:'G#4', u:'A#4', o:'C#5', p:'D#5',
    z:'F3', x:'G3', c:'A3', v:'B3',
    a:'C4', s:'D4', d:'E4', f:'F4', g:'G4', h:'A4', j:'B4', k:'C5', l:'D5',
    b:'E5', n:'F5', m:'G5', ',':'A5', '.':'B5'
  }
};

const keyRows = [
  ['q','w','e','r','t','y','u','i','o','p'],
  ['a','s','d','f','g','h','j','k','l'],
  ['z','x','c','v','b','n','m',',','.']
];
const keyOrderFlat = keyRows.flat();
const keyMap = ['z','x','c','v','b','n','m',',']; // legacy note order for quick mapping if needed
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const buffersByInstrument = {}; // instrument -> { name -> AudioBuffer|undefined }
let keymapJson = {}; // loaded from keymap.json
let pressedKeys = new Set();
let shiftHeld = false;
let spaceHeld = false; // Track if spacebar is held for sharp notes
let transposeOctaves = 0; // number of octaves to shift keymap (+ up, - down)
let openedSongFilename = '';

// Song state
let songTokens = []; // [{text: string, notes: ["C4",...], doneSteps: number}]
let songPos = 0; // index in songTokens
let showSongNotes = true;
let highlightKeyboardGuide = true;
let showSolfege = false;
let songMode = false;
let composerMode = false;
let composerSelectedIndex = null; // selected token index for composing
let chordProgress = new Set(); // tracks notes hit for current chord step
let ctrlHeld = false; // track CTRL for chord composing
let spaceHeldGuide = false; // hold Space to temporarily show guide when highlight is off

function transposeNote(name, octs) {
  if (!name || !octs) return name;
  const m = String(name).trim().match(/^([A-G])(#|b)?(\d)$/i);
  if (!m) return name;
  const L = m[1].toUpperCase();
  const acc = m[2] || '';
  const o = parseInt(m[3], 10);
  const o2 = o + octs;
  return `${L}${acc}${o2}`;
}
function getCurrentMap(inst = currentInstrument) {
  const fromFile = (keymapJson && keymapJson[inst]) || null;
  const fromDefault = (DEFAULT_KEYMAP && DEFAULT_KEYMAP[inst]) || null;
  const base = fromFile || fromDefault || {};
  if (!transposeOctaves) return base;
  const shifted = {};
  for (const k in base) shifted[k] = transposeNote(base[k], transposeOctaves);
  return shifted;
}

// Shift-specific sharp overrides per key (then transposed by current octave shift)
function getShiftOverride(key) {
  const k = String(key || '').toLowerCase();
  let base = null;
  if (k === 's') base = 'F#3';
  else if (k === 'd') base = 'G#3';
  else if (k === 'f') base = 'A#3';
  else if (k === 'j') base = 'F#5';
  else if (k === 'k') base = 'G#5';
  else if (k === 'l') base = 'A#5';
  return base ? transposeNote(base, transposeOctaves) : null;
}

function toSharpIfNeeded(name, useSharp) {
  if (!useSharp || !name) return name;
  const m = name.match(/^([A-G])(#|b)?(\d)$/);
  if (!m) return name;
  const base = m[1];
  const accidental = m[2] || '';
  const oct = m[3];
  // Only sharpify for F,G,A,C,D when no existing accidental
  const eligible = { F:1, G:1, A:1, C:1, D:1 };
  if (!eligible[base] || accidental) return name;
  // Edge case for E and B are excluded by eligible
  return base + '#' + oct;
}

// Convert note name to solfege with octave (e.g., C4 -> "do 4", F#3 -> "fa# 3")
function noteToSolfege(name) {
  if (!name) return '-';
  const m = name.match(/^([A-G])(#|b)?(\d)$/);
  if (!m) return name;
  const base = m[1];
  const acc = m[2] || '';
  const oct = m[3];
  const map = { C:'do', D:'re', E:'mi', F:'fa', G:'sol', A:'la', B:'si' };
  const syl = map[base] || base.toLowerCase();
  const accTxt = acc === '#' ? '#' : (acc === 'b' ? 'b' : '');
  return syl + accTxt + ' ' + oct;
}

function formatKeyLabel(note) {
  const n = note;
  if (showSolfege) return noteToSolfege(n);
  return n || '-';
}

function ensureAudioContext() {
  if (audioCtx.state === 'suspended') {
    audioCtx.resume().catch(()=>{});
  }
}

// --- Marimba (percussive mallet resonators)
function playMarimba(noteName) {
  ensureAudioContext();
  const f0 = noteToFreq(noteName);
  const now = audioCtx.currentTime;
  const master = audioCtx.createGain(); master.gain.value = 0.95;
  // Short noise burst as excitation
  const burstLen = Math.max(1, Math.floor(audioCtx.sampleRate * 0.012));
  const noiseBuf = audioCtx.createBuffer(1, burstLen, audioCtx.sampleRate);
  const ch = noiseBuf.getChannelData(0);
  for (let i=0;i<burstLen;i++){ ch[i] = (Math.random()*2-1) * (1 - i/burstLen); }
  const noise = audioCtx.createBufferSource(); noise.buffer = noiseBuf; noise.loop = false;
  const nEnv = audioCtx.createGain(); nEnv.gain.setValueAtTime(0.0001, now); nEnv.gain.exponentialRampToValueAtTime(1.0, now + 0.002); nEnv.gain.exponentialRampToValueAtTime(0.0001, now + 0.05);
  // Bar mode ratios for marimba-like timbre (approx)
  const ratios = [1.00, 2.756, 5.404];
  const gains  = [0.9, 0.55, 0.35];
  const Qs     = [18,   14,    12];
  const modes = audioCtx.createGain(); modes.gain.value = 0.9;
  ratios.forEach((r,i)=>{
    const bp = audioCtx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.value = Math.min(f0*r, 12000); bp.Q.value = Qs[i];
    const g  = audioCtx.createGain(); g.gain.value = gains[i];
    noise.connect(nEnv).connect(bp).connect(g).connect(modes);
  });
  // Soft body lowpass for wood tone
  const toneLP = audioCtx.createBiquadFilter(); toneLP.type='lowpass'; toneLP.frequency.value = 4800; toneLP.Q.value = 0.4;
  // Output envelope (decay ~2.2s)
  const out = audioCtx.createGain();
  out.gain.setValueAtTime(0.0001, now);
  out.gain.exponentialRampToValueAtTime(0.9, now + 0.004);
  out.gain.exponentialRampToValueAtTime(0.0001, now + 2.2);
  modes.connect(toneLP).connect(out).connect(master).connect(audioCtx.destination);
  noise.start(now); noise.stop(now + 0.05);
}

function noteToFreq(n) {
  // Parse like C#4, Db4, etc.
  const A4 = 440;
  const map = { C:0, 'C#':1, Db:1, D:2, 'D#':3, Eb:3, E:4, F:5, 'F#':6, Gb:6, G:7, 'G#':8, Ab:8, A:9, 'A#':10, Bb:10, B:11 };
  const m = n.match(/^([A-G](?:#|b)?)(\d)$/);
  if (!m) return 440;
  const semi = (parseInt(m[2],10) - 4) * 12 + (map[m[1]] - 9);
  return A4 * Math.pow(2, semi/12);
}

// --- Guitar (Karplus–Strong) ---
function playGuitarKS(name) {
  const frequency = noteToFreq(name);
  const sr = audioCtx.sampleRate;
  const N = Math.max(2, Math.round(sr / frequency));
  const duration = 2.2;
  const outLen = Math.round(sr * duration);
  const decay = 0.994;
  const ring = new Float32Array(N);
  for (let i = 0; i < N; i++) ring[i] = Math.random() * 2 - 1;
  const buffer = audioCtx.createBuffer(1, outLen, sr);
  const buf = buffer.getChannelData(0);
  let ptr = 0;
  for (let t = 0; t < outLen; t++) {
    const cur = ring[ptr];
    const nextIndex = (ptr + 1) % N;
    const newVal = decay * 0.5 * (ring[ptr] + ring[nextIndex]);
    buf[t] = cur;
    ring[ptr] = newVal;
    ptr = nextIndex;
  }
  const src = audioCtx.createBufferSource();
  src.buffer = buffer;
  const highFilter = audioCtx.createBiquadFilter();
  highFilter.type = 'highshelf';
  highFilter.frequency.value = 1200;
  highFilter.gain.value = -3;
  const gain = audioCtx.createGain();
  gain.gain.value = 0.9;
  src.connect(highFilter);
  highFilter.connect(gain);
  gain.connect(audioCtx.destination);
  src.start();
}

// --- Flute (Sáo) sustain helpers ---
function startFluteSustain(note) {
  const freq = noteToFreq(note);
  const osc = audioCtx.createOscillator();
  osc.type = 'sine';
  osc.frequency.value = freq;
  const lfo = audioCtx.createOscillator();
  const lfoGain = audioCtx.createGain();
  lfo.frequency.value = 5; // Hz
  lfoGain.gain.value = 10; // cents
  lfo.connect(lfoGain).connect(osc.detune);
  const gain = audioCtx.createGain();
  const now = audioCtx.currentTime;
  gain.gain.setValueAtTime(0.0001, now);
  gain.gain.exponentialRampToValueAtTime(0.55, now + 0.06); // attack
  osc.connect(gain).connect(audioCtx.destination);
  osc.start();
  lfo.start();
  let stopped = false;
  return function stop() {
    if (stopped) return; stopped = true;
    const t = audioCtx.currentTime;
    try {
      gain.gain.cancelScheduledValues(t);
      gain.gain.setValueAtTime(gain.gain.value, t);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);
    } catch(_) {}
    try { osc.stop(t + 0.14); } catch(_) {}
    try { lfo.stop(t + 0.14); } catch(_) {}
  };
}

// --- Đàn bầu sustain helpers (rich vibrato, long sustain)
function startDanBauSustain(note) {
  const freq = noteToFreq(note);
  const osc = audioCtx.createOscillator();
  // Mixture for hơi ấm và giàu hài âm bậc thấp
  const osc2 = audioCtx.createOscillator();
  osc.type = 'sine';
  osc.frequency.value = freq;
  osc2.type = 'triangle';
  osc2.frequency.value = freq * 2; // nhẹ hài bậc 2

  // Vibrato mạnh và chậm hơn sáo
  const lfo = audioCtx.createOscillator();
  const lfoGain = audioCtx.createGain();
  lfo.frequency.value = 5.5; // chậm hơn
  lfoGain.gain.value = 45; // rung rộng hơn (cents)
  lfo.connect(lfoGain).connect(osc.detune);
  // thêm rung nhẹ lệch pha cho osc2
  const lfo2 = audioCtx.createOscillator();
  const lfo2Gain = audioCtx.createGain();
  lfo2.frequency.value = 4.8;
  lfo2Gain.gain.value = 16;
  lfo2.connect(lfo2Gain).connect(osc2.detune);

  // Attack glide: kéo cao độ lên đích trong 120ms
  try {
    osc.detune.setValueAtTime(-20, audioCtx.currentTime);
    osc.detune.linearRampToValueAtTime(0, audioCtx.currentTime + 0.12);
  } catch(_){ }

  // Formant filter để ấm hơn
  const bp = audioCtx.createBiquadFilter();
  bp.type = 'bandpass';
  bp.frequency.value = Math.min(1800, freq * 3);
  bp.Q.value = 0.9;

  // Low-pass dịu bớt chói
  const lp = audioCtx.createBiquadFilter();
  lp.type = 'lowpass';
  lp.frequency.value = 3200;
  lp.Q.value = 0.8;

  // Envelope dài
  const gain = audioCtx.createGain();
  const now = audioCtx.currentTime;
  gain.gain.setValueAtTime(0.0001, now);
  gain.gain.exponentialRampToValueAtTime(0.75, now + 0.09); // attack mượt hơn

  // Wiring
  const mix = audioCtx.createGain(); mix.gain.value = 0.8;
  osc.connect(mix); osc2.connect(mix);
  // Ambience nhẹ với feedback delay
  const delay = audioCtx.createDelay(1.2); delay.delayTime.value = 0.22;
  const fb = audioCtx.createGain(); fb.gain.value = 0.15; delay.connect(fb).connect(delay);
  const wet = audioCtx.createGain(); wet.gain.value = 0.18;
  const dry = audioCtx.createGain(); dry.gain.value = 0.95;
  const pre = audioCtx.createGain();
  mix.connect(bp).connect(lp).connect(pre);
  pre.connect(dry).connect(gain);
  pre.connect(delay).connect(wet).connect(gain);
  gain.connect(audioCtx.destination);
  osc.start(); osc2.start(); lfo.start(); lfo2.start();

  let stopped = false;
  return function stop() {
    if (stopped) return; stopped = true;
    const t = audioCtx.currentTime;
    try {
      gain.gain.cancelScheduledValues(t);
      gain.gain.setValueAtTime(gain.gain.value, t);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 1.8); // long release hơn
    } catch(_){ }
    try { osc.stop(t + 1.25); osc2.stop(t + 1.25); lfo.stop(t + 1.25); lfo2.stop(t + 1.25); } catch(_){ }
  };
}

// --- Tank Drum modal synthesis (rich, ringing, ambient)
function playTankDrum(noteName) {
  const freq = noteToFreq(noteName);
  const now = audioCtx.currentTime;
  const master = audioCtx.createGain(); master.gain.value = 1.0;
  // Noise excitation
  const noiseBuf = audioCtx.createBuffer(1, Math.max(1, Math.floor(audioCtx.sampleRate * 0.06)), audioCtx.sampleRate);
  const ch = noiseBuf.getChannelData(0);
  for (let i=0;i<ch.length;i++){ ch[i] = (Math.random()*2-1) * (1 - i/ch.length); }
  const noise = audioCtx.createBufferSource(); noise.buffer = noiseBuf; noise.loop = false;
  const nEnv = audioCtx.createGain(); nEnv.gain.setValueAtTime(0.0001, now); nEnv.gain.exponentialRampToValueAtTime(0.7, now + 0.002); nEnv.gain.exponentialRampToValueAtTime(0.0001, now + 0.08);
  // Modal bandpass stack (slightly darker balance)
  const ratios = [1.0, 1.45, 1.9, 2.4];
  const gains  = [0.95, 0.55, 0.35, 0.22];
  const Qs     = [16, 12, 10, 9];
  const modes = audioCtx.createGain(); modes.gain.value = 0.85;
  ratios.forEach((r,i)=>{
    const bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = Math.min(freq*r, 12000); bp.Q.value = Qs[i];
    const g = audioCtx.createGain(); g.gain.value = gains[i];
    noise.connect(nEnv).connect(bp).connect(g).connect(modes);
  });
  // Body oscillators (more fundamental, less upper content)
  const osc1 = audioCtx.createOscillator(); osc1.type='sine'; osc1.frequency.value = freq;
  const osc2 = audioCtx.createOscillator(); osc2.type='triangle'; osc2.frequency.value = freq*2.0;
  const body = audioCtx.createGain();
  body.gain.setValueAtTime(0.0001, now);
  body.gain.exponentialRampToValueAtTime(0.65, now + 0.012);
  body.gain.exponentialRampToValueAtTime(0.0001, now + 2.9);
  osc1.connect(body); osc2.connect(body);
  // Ambience
  const delay = audioCtx.createDelay(1.0); delay.delayTime.value = 0.21;
  const fb = audioCtx.createGain(); fb.gain.value = 0.18; delay.connect(fb).connect(delay);
  const wet = audioCtx.createGain(); wet.gain.value = 0.2;
  const dry = audioCtx.createGain(); dry.gain.value = 0.92;
  // Gentle tone shaper to warm highs
  const warmLP = audioCtx.createBiquadFilter(); warmLP.type = 'lowpass'; warmLP.frequency.value = 3200; warmLP.Q.value = 0.5;
  const premix = audioCtx.createGain();
  modes.connect(premix); body.connect(premix);
  premix.connect(dry).connect(master);
  premix.connect(delay).connect(wet).connect(master);
  master.connect(warmLP).connect(audioCtx.destination);
  // Start/stop
  const stopAt = now + 3.2;
  noise.start(now); noise.stop(now + 0.08);
  osc1.start(now); osc2.start(now);
  try { osc1.stop(stopAt); osc2.stop(stopAt); } catch(_) {}
}

// --- Guitar (plucked string, Karplus–Strong style)
function playGuitar(noteName){
  ensureAudioContext();
  const f = noteToFreq(noteName);
  const now = audioCtx.currentTime;
  const sr = audioCtx.sampleRate;
  const period = 1 / Math.max(40, Math.min(2000, f));
  // Excitation burst (pick) – slightly brighter, short
  const excLen = Math.max(1, Math.floor(sr * 0.012));
  const buf = audioCtx.createBuffer(1, excLen, sr);
  const ch = buf.getChannelData(0);
  for (let i=0;i<excLen;i++) ch[i] = (Math.random()*2-1) * (1 - i/excLen);
  const src = audioCtx.createBufferSource(); src.buffer = buf; src.loop = false;
  // Pick-position feedforward comb (src - delayed(src)) to shape notch pattern
  const pickDelay = audioCtx.createDelay(0.01);
  // Pick position approx 20–25% of string length
  pickDelay.delayTime.value = Math.min(0.008, period * 0.23);
  const inv = audioCtx.createGain(); inv.gain.value = -0.8;
  const pickMix = audioCtx.createGain(); pickMix.gain.value = 1.0;
  src.connect(pickMix);
  src.connect(pickDelay).connect(inv);
  inv.connect(pickMix);
  // Loop with dual damping (lowpass to remove highs, highpass to remove DC)
  const loopDelay = audioCtx.createDelay(1.0); loopDelay.delayTime.value = period;
  const fb = audioCtx.createGain(); fb.gain.value = 0.6; // sustain
  const lpDamp = audioCtx.createBiquadFilter(); lpDamp.type='lowpass'; lpDamp.frequency.value = 3000; lpDamp.Q.value = 0.25;
  const hpDamp = audioCtx.createBiquadFilter(); hpDamp.type='highpass'; hpDamp.frequency.value = 60; hpDamp.Q.value = 0.7;
  loopDelay.connect(lpDamp).connect(hpDamp).connect(fb).connect(loopDelay);
  // Body resonances (two bands)
  const body1 = audioCtx.createBiquadFilter(); body1.type='bandpass'; body1.frequency.value = Math.max(180, Math.min(260, f*0.8)); body1.Q.value = 1.0;
  const body2 = audioCtx.createBiquadFilter(); body2.type='bandpass'; body2.frequency.value = Math.max(300, Math.min(420, f*1.1)); body2.Q.value = 0.8;
  // Output envelope and tone
  const out = audioCtx.createGain();
  out.gain.setValueAtTime(0.0001, now);
  out.gain.exponentialRampToValueAtTime(0.9, now + 0.005);
  out.gain.exponentialRampToValueAtTime(0.0001, now + 2.6);
  const outLP = audioCtx.createBiquadFilter(); outLP.type='lowpass'; outLP.frequency.value = 3600; outLP.Q.value = 0.5;
  const postGain = audioCtx.createGain(); postGain.gain.value = 1.3;
  // Wire graph
  pickMix.connect(loopDelay);
  loopDelay.connect(body1).connect(body2).connect(out).connect(outLP).connect(postGain).connect(audioCtx.destination);
  src.start(now); src.stop(now + 0.02);
}

async function loadSamplesForInstrument(instKey) {
  const inst = instruments[instKey];
  const bufs = buffersByInstrument[instKey] || (buffersByInstrument[instKey] = {});
  for (let i = 0; i < inst.notes.length; i++) {
    const name = inst.notes[i];
    const path = inst.pathPrefix + name + '.wav';
    try {
      const res = await fetch(path);
      if (!res.ok) throw new Error('Missing sample');
      const ab = await res.arrayBuffer();
      const buf = await audioCtx.decodeAudioData(ab);
      bufs[name] = buf;
    } catch (e) {
      bufs[name] = undefined; // fallback to synth
    }
  }
}

async function loadKeymap() {
  // Prefer shared JS keymap when available; otherwise fall back to DEFAULT_KEYMAP
  if (window && window.SHARED_KEYMAP) {
    const shared = window.SHARED_KEYMAP;
    keymapJson = {
      'piano': shared,
      'tank-drum': shared,
      'sao': shared,
      'marimba': shared,
      'handpan': shared,
      'dan-da': shared,
      'dan-bau': shared
    };
    return;
  }
  keymapJson = DEFAULT_KEYMAP;
}

function makeKeyButton(k, mappedNote, available) {
  const btn = document.createElement('div');
  btn.className = 'key';
  btn.setAttribute('data-key', k);
  const bottomRowKeys = new Set(['x','c','b','m',',']);
  const effNote = ((shiftHeld || spaceHeld) && !bottomRowKeys.has(k)) ? (getShiftOverride(k) || mappedNote) : mappedNote;
  btn.innerHTML = `<div class="k">${k.toUpperCase()}</div><div class="n">${formatKeyLabel(effNote || '')}</div>`;
  if (!available && mappedNote) btn.classList.add('unavailable');
  btn.addEventListener('pointerdown', ()=> {
    ensureAudioContext();
    btn.classList.add('active');
    // If song guide expects the shift-sharp for this key, play that even without Shift
    const expected = getExpectedNextNote();
    const shiftName = (!bottomRowKeys.has(k) ? getShiftOverride(k) : null);
    const matchExpected = Array.isArray(expected) ? (expected && shiftName && expected.includes(shiftName)) : (expected && shiftName === expected);
    const playName = matchExpected ? shiftName : (((shiftHeld || spaceHeld) && !bottomRowKeys.has(k)) ? (shiftName || mappedNote) : mappedNote);
    // Staff highlight
    if (playName) {
      setStaffNoteActive(playName, true);
      btn.dataset.staffNote = playName;
    }
    // Composer capture first (even if not playable)
    if (composerMode && composerSelectedIndex !== null && playName) {
      const tok = songTokens[composerSelectedIndex];
      if (tok && tok.text !== '\n') {
        composerAddNote(tok, playName, ctrlHeld);
        renderSong();
      }
    }
    if (playName && available) {
      if (currentInstrument === 'piano' && window.tonePiano) {
        // Song guidance advances only in song mode
        if (songMode) handleNotePlayed(playName);
        window.tonePiano.attack(playName);
        btn.dataset.activeNote = playName;
      } else if (currentInstrument === 'sao') {
        // Sáo sustain while holding
        if (songMode) handleNotePlayed(playName);
        btn._fluteStop = startFluteSustain(playName);
      } else if (currentInstrument === 'dan-bau') {
        if (songMode) handleNotePlayed(playName);
        btn._danBauStop = startDanBauSustain(playName);
      } else {
        playNote(playName);
      }
    }
  });
  btn.addEventListener('pointerup', ()=> {
    btn.classList.remove('active');
    if (currentInstrument === 'piano' && window.tonePiano && btn.dataset.activeNote) {
      window.tonePiano.release(btn.dataset.activeNote);
      delete btn.dataset.activeNote;
    } else if (currentInstrument === 'sao' && btn._fluteStop) {
      try { btn._fluteStop(); } catch(_){}
      delete btn._fluteStop;
    } else if (currentInstrument === 'dan-bau' && btn._danBauStop) {
      try { btn._danBauStop(); } catch(_){ }
      delete btn._danBauStop;
    }
  });
  btn.addEventListener('pointerleave', ()=> {
    btn.classList.remove('active');
    if (currentInstrument === 'piano' && window.tonePiano && btn.dataset.activeNote) {
      window.tonePiano.release(btn.dataset.activeNote);
      delete btn.dataset.activeNote;
    } else if (currentInstrument === 'sao' && btn._fluteStop) {
      try { btn._fluteStop(); } catch(_){ }
      delete btn._fluteStop;
    } else if (currentInstrument === 'dan-bau' && btn._danBauStop) {
      try { btn._danBauStop(); } catch(_){ }
      delete btn._danBauStop;
    }
  });
  btn.addEventListener('pointercancel', ()=> {
    btn.classList.remove('active');
    if (btn.dataset.staffNote) { setStaffNoteActive(btn.dataset.staffNote, false); delete btn.dataset.staffNote; }
    if (currentInstrument === 'piano' && window.tonePiano && btn.dataset.activeNote) {
      window.tonePiano.release(btn.dataset.activeNote);
      delete btn.dataset.activeNote;
    } else if (currentInstrument === 'sao' && btn._fluteStop) {
      try { btn._fluteStop(); } catch(_){ }
      delete btn._fluteStop;
    } else if (currentInstrument === 'dan-bau' && btn._danBauStop) {
      try { btn._danBauStop(); } catch(_){ }
      delete btn._danBauStop;
    }
  });
  return btn;
}

function playNote(name) {
  // Validate against song if any
  if (songMode) handleNotePlayed(name);
  const synthType = instruments[currentInstrument].synth;
  if (synthType === 'guitar') { playGuitarKS(name); return; }
  if (synthType === 'marimba') { playMarimba(name); return; }
  if (currentInstrument === 'piano' && window.tonePiano) {
    window.tonePiano.play(name);
    return;
  }
  const bufs = buffersByInstrument[currentInstrument] || {};
  const buf = bufs[name];
  (window._playing = window._playing || []);
  if (buf) {
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    const gain = audioCtx.createGain();
    gain.gain.value = 1.0;
    src.connect(gain).connect(audioCtx.destination);
    src.start();
    window._playing.push({ stop: () => { try { src.stop(); } catch(_){} }, node: src });
    src.onended = ()=> {
      const idx = window._playing.findIndex(o=>o.node===src);
      if (idx>=0) window._playing.splice(idx,1);
    };
    return;
  }
  const freq = noteToFreq(name);
  if (synthType === 'percussive') {
    playTankDrum(name);
    return;
  } else if (synthType === 'handpan') {
    // Handpan: soft attack, rich overtones, long decay (~3.2s)
    const oscFund = audioCtx.createOscillator();
    const oscOver = audioCtx.createOscillator();
    oscFund.type = 'sine';
    oscOver.type = 'triangle';
    oscFund.frequency.value = freq;
    oscOver.frequency.value = freq * 2.01;
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = freq * 1.4;
    filter.Q.value = 7;
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(0.9, now + 0.008);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 1.8);
    oscFund.connect(filter);
    oscOver.connect(filter);
    filter.connect(gain).connect(audioCtx.destination);
    oscFund.start();
    oscOver.start();
    const stopAt = now + 1.85;
    oscFund.stop(stopAt);
    oscOver.stop(stopAt);
    const playingObj = { stop: () => { try { oscFund.stop(); } catch(_){} try { oscOver.stop(); } catch(_){} }, node: oscFund };
    window._playing.push(playingObj);
    oscFund.onended = () => {
      const idx = window._playing.indexOf(playingObj);
      if (idx>=0) window._playing.splice(idx,1);
    };
  } else if (synthType === 'lithophone') {
    // Lithophone (Đàn đá): bright mallet, glassy tone, medium-long decay (~2.4s)
    const osc = audioCtx.createOscillator();
    const oscH = audioCtx.createOscillator();
    osc.type = 'sine';
    oscH.type = 'square';
    osc.frequency.value = freq;
    oscH.frequency.value = freq * 3.0;
    const hp = audioCtx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 200;
    const bp = audioCtx.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.value = freq * 1.1;
    bp.Q.value = 10;
    const gain = audioCtx.createGain();
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(0.85, now + 0.005);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 2.4);
    osc.connect(hp).connect(bp);
    oscH.connect(bp);
    bp.connect(gain).connect(audioCtx.destination);
    osc.start();
    oscH.start();
    const stopAt = now + 2.45;
    osc.stop(stopAt);
    oscH.stop(stopAt);
    const playingObj = { stop: () => { try { osc.stop(); } catch(_){} try { oscH.stop(); } catch(_){} }, node: osc };
    window._playing.push(playingObj);
    osc.onended = () => {
      const idx = window._playing.indexOf(playingObj);
      if (idx>=0) window._playing.splice(idx,1);
    };
  } else {
    // Sáo: longer sustain (~2.2s) with gentle vibrato
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const lfo = audioCtx.createOscillator();
    const lfoGain = audioCtx.createGain();
    lfo.frequency.value = 5; // 5 Hz vibrato
    lfoGain.gain.value = 10; // cents
    lfo.connect(lfoGain).connect(osc.detune);
    const gain = audioCtx.createGain();
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(0.55, now + 0.08);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 2.2);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start();
    lfo.start();
    const stopAt = now + 2.25;
    osc.stop(stopAt);
    lfo.stop(stopAt);
    const playingObj = { stop: () => { try { osc.stop(); } catch(_){} try { lfo.stop(); } catch(_){} }, node: osc };
    window._playing.push(playingObj);
    osc.onended = () => {
      const idx = window._playing.indexOf(playingObj);
      if (idx>=0) window._playing.splice(idx,1);
    };
  }
}

function stopAll() {
  if (!window._playing) return;
  window._playing.forEach(o=>{ try{ o.stop(); } catch(e){} });
  window._playing = [];
  if (currentInstrument === 'piano' && window.tonePiano) {
    window.tonePiano.stopAll();
  }
  if (window._fluteActiveByKey) {
    for (const k in window._fluteActiveByKey) {
      try { window._fluteActiveByKey[k](); } catch(_){ }
      delete window._fluteActiveByKey[k];
    }
  }
}

function updateSongModeUI() {
  const sc = document.querySelector('.song-controls');
  const sa = document.getElementById('songArea');
  const st = document.getElementById('songTop');
  if (!sc || !sa) return;
  const show = songMode || composerMode;
  sc.style.display = show ? '' : 'none';
  sa.style.display = show ? '' : 'none';
  if (st) st.style.display = show ? '' : 'none';
  if (!songMode) {
    // Clear any guide highlights when hiding
    document.querySelectorAll('.key.guide').forEach(el=> el.classList.remove('guide'));
    document.querySelectorAll('.key.guide-sharp').forEach(el=> el.classList.remove('guide-sharp'));
    const gl = document.getElementById('githubSongList');
    if (gl) gl.style.display = 'none';
  } else {
    updateKeyboardGuideHighlight();
    // Show GitHub song list when in song mode
    const gl = document.getElementById('githubSongList');
    if (gl) {
      gl.style.display = '';
      // Lazy load only once per session
      if (!gl.dataset.loaded) {
        fetchGithubSongs().catch(()=>{
          gl.innerHTML = '<em>Không tải được danh sách bài hát từ GitHub.</em>';
        });
      }
    }
  }
  // Composer controls visibility
  const cc = document.getElementById('composerControls');
  if (cc) cc.style.display = composerMode ? '' : 'none';
  const cst = document.getElementById('composerStaff');
  const staffToggle = document.getElementById('toggleStaff');
  if (cst) cst.style.display = (staffToggle && staffToggle.checked) ? '' : 'none';
  try { renderComposerStaff(); } catch(_) {}
}

// Fetch and render .txt songs from GitHub repo albertthai-alt/browse in folder /keyboard-music
async function fetchGithubSongs() {
  const gl = document.getElementById('githubSongList');
  if (!gl) return;
  gl.textContent = 'Đang tải danh sách bài hát từ GitHub...';
  const api = 'https://api.github.com/repos/albertthai-alt/browse/contents/keyboard-music';
  const res = await fetch(api, { headers: { 'Accept': 'application/vnd.github.v3+json' } });
  if (!res.ok) throw new Error('GitHub API error');
  /** @type {{name:string,path:string,download_url:string,type:string}[]} */
  const items = await res.json();
  const txts = (Array.isArray(items) ? items : []).filter(it=> it && it.type === 'file' && /\.txt$/i.test(it.name));
  if (txts.length === 0) { gl.innerHTML = '<em>Chưa có file .txt nào.</em>'; gl.dataset.loaded = '1'; return; }
  const frag = document.createDocumentFragment();
  const list = document.createElement('div');
  list.style.display = 'flex';
  list.style.flexWrap = 'wrap';
  list.style.gap = '8px 12px';
  for (const f of txts) {
    const a = document.createElement('a');
    a.href = '#';
    a.textContent = f.name;
    a.dataset.downloadUrl = f.download_url || '';
    a.style.textDecoration = 'none';
    a.style.padding = '4px 8px';
    a.style.border = '1px solid #eee';
    a.style.borderRadius = '6px';
    a.style.background = '#fff';
    a.style.color = '#0b2545';
    a.addEventListener('click', async (ev)=>{
      ev.preventDefault();
      const url = a.dataset.downloadUrl;
      if (!url) return;
      a.textContent = f.name + ' (đang tải...)';
      try {
        const r = await fetch(url);
        const txt = await r.text();
        songTokens = parseSong(txt);
        songPos = 0;
        renderSong();
        updateSongHighlight();
        updateComposerStatus();
      } catch (e) {
        console.error(e);
        alert('Không đọc được file từ GitHub: ' + f.name);
      } finally {
        a.textContent = f.name;
      }
    });
    list.appendChild(a);
  }
  frag.appendChild(list);
  gl.innerHTML = '';
  gl.appendChild(frag);
  gl.dataset.loaded = '1';
}

function rebuildUI() {
  const kb = document.getElementById('keyboard');
  kb.innerHTML = '';
  const inst = instruments[currentInstrument];
  const currentMap = getCurrentMap();
  // Ensure CSS --cols matches the longest row for perfect centering
  try {
    const maxLen = Math.max(...keyRows.map(r=> r.length));
    kb.style.setProperty('--cols', String(maxLen));
  } catch(_){}
  keyRows.forEach((rowKeys, idx)=>{
    const row = document.createElement('div');
    row.className = 'row ' + (idx===0?'r1':idx===1?'r2':'r3');
    // Inform CSS about how many keys this row has for trailing spacer calc
    try { row.style.setProperty('--len', String(rowKeys.length)); } catch(_){}
    rowKeys.forEach(k=>{
      const note = currentMap[k] || '';
      const available = !!note && (inst.notes.length === 0 || inst.notes.includes(note));
      const el = makeKeyButton(k, note, available);
      // Right-hand coloring groups
      // Middle row: A..J use rh-mid; K,L share rh-r3 like B group
      if (idx === 1 && ['a','s','d','f','g','h','j'].includes(k)) el.classList.add('rh-mid');
      if (idx === 1 && ['k','l'].includes(k)) el.classList.add('rh-r3');
      // Bottom row groupings
      // Black keys on top row sharps (W,E,T,Y,U,O,P)
      if (idx === 0 && ['w','e','t','y','u','o','p'].includes(k) && note) el.classList.add('sharp');
      if (idx === 2 && ['z','x','c','v'].includes(k)) el.classList.add('rh-r2');
      if (idx === 2 && ['b','n','m',',','.'].includes(k)) el.classList.add('rh-r3');
      row.appendChild(el);
    });
    kb.appendChild(row);
  });
}

function refreshLabelsForShift() {
  const currentMap = getCurrentMap();
  for (const k of keyRows.flat()) {
    const bottom = (k === 'x' || k === 'c' || k === 'b' || k === 'm' || k === ',');
    const note = ((shiftHeld || spaceHeld) && !bottom ? (getShiftOverride(k) || currentMap[k]) : currentMap[k]) || '';
    const el = document.querySelector(`[data-key="${CSS.escape(k)}"] .n`);
    if (el) el.textContent = formatKeyLabel(note);
    // Toggle sharp styling for shift-based sharp keys (S,D,F,J,K,L) when Shift is held
    const keyEl = document.querySelector(`[data-key="${CSS.escape(k)}"]`);
    if (keyEl) {
      if ((shiftHeld || spaceHeld) && (k === 's' || k === 'd' || k === 'f' || k === 'j' || k === 'k' || k === 'l')) keyEl.classList.add('sharp');
      else if (!(k === 'w' || k === 'e' || k === 't' || k === 'y' || k === 'u' || k === 'o' || k === 'p')) keyEl.classList.remove('sharp');
    }
  }
}

// --- Song parsing and rendering ---
function parseSong(text) {
  const lines = text.split(/\r?\n/);
  const seq = [];
  for (let li = 0; li < lines.length; li++) {
    const line = lines[li];
    if (line.trim() === '') { seq.push({text:'\n', notes:[], doneSteps:0}); continue; }
    const parts = line.split(/\s+/);
    for (const part of parts) {
      if (!part) continue;
      const tok = { text: (part.replace(/\{[^}]*\}/g,'') || part), notes: [], doneSteps: 0 };
      // Extract all brace groups like {C4E5} or {C4}{E5}
      const groups = part.match(/\{([^}]*)\}/g) || [];
      for (const g of groups) {
        const inner = g.slice(1,-1);
        const all = inner.match(/[A-G](?:#|b)?\d/g) || [];
        if (all.length > 1) tok.notes.push(all); // chord step
        else if (all.length === 1) tok.notes.push(all[0]);
      }
      seq.push(tok);
    }
    // Preserve line breaks between non-empty lines
    if (li < lines.length - 1) seq.push({text:'\n', notes:[], doneSteps:0});
  }
  return seq;
}

function renderSong() {
  const area = document.getElementById('songArea');
  area.innerHTML = '';
  let line = document.createElement('div');
  area.appendChild(line);
  let lineCount = 1;
  for (let i = 0; i < songTokens.length; i++) {
    const tok = songTokens[i];
    if (tok.text === '\n') { line = document.createElement('div'); area.appendChild(line); lineCount++; continue; }
    const span = document.createElement('span');
    span.className = 'token';
    if (i === songPos) span.classList.add('current');
    if (composerMode && i === composerSelectedIndex) span.classList.add('editing');
    span.textContent = tok.text;
    const hints = document.createElement('span');
    hints.className = 'hints';
    if (showSongNotes && tok.notes && tok.notes.length) {
      hints.textContent = tok.notes.map(step => Array.isArray(step) ? step.join('') : step).join(' ');
    } else {
      hints.textContent = '';
    }
    span.appendChild(hints);
    span.setAttribute('data-index', String(i));
    span.style.cursor = composerMode ? 'pointer' : 'default';
    span.addEventListener('click', ()=>{
      if (composerMode) {
        composerSelectedIndex = i;
        updateComposerStatus();
        renderSong();
        // If this word already has notes, play them immediately
        const tokNow = songTokens[i];
        if (tokNow && tokNow.notes && tokNow.notes.length) {
          try { ensureAudioContext(); } catch(_){ }
          tokNow.notes.forEach((nn, idx)=> setTimeout(()=>{ try { playNote(nn); } catch(_){ } }, idx * 180));
        }
        return;
      }
      if (songMode) {
        songPos = i;
        // Reset progress for this and subsequent tokens to force replaying
        for (let j = i; j < songTokens.length; j++) {
          if (songTokens[j] && Array.isArray(songTokens[j].notes)) songTokens[j].doneSteps = 0;
        }
        try { chordProgress.clear(); } catch(_){ }
        updateSongHighlight();
      }
    });
    line.appendChild(span);
  }
  updateKeyboardGuideHighlight();
  // Toggle scroll if composer mode and more than ~6 lines
  if (typeof composerMode !== 'undefined' && composerMode && lineCount > 6) area.classList.add('scrollable');
  else area.classList.remove('scrollable');
}

function scrollToCurrentToken() {
  const currentToken = document.querySelector('#songArea .token.current');
  if (!currentToken) return;
  
  const songTop = document.getElementById('songTop');
  if (!songTop) return;
  
  const tokenRect = currentToken.getBoundingClientRect();
  const containerRect = songTop.getBoundingClientRect();
  
  // Calculate if token is outside the visible area
  if (tokenRect.top < containerRect.top + 30) {
    // Scroll up to show the token near the top (with some padding)
    currentToken.scrollIntoView({ behavior: 'smooth', block: 'start' });
  } else if (tokenRect.bottom > containerRect.bottom - 30) {
    // Scroll down to show the token near the bottom (with some padding)
    currentToken.scrollIntoView({ behavior: 'smooth', block: 'end' });
  }
}

function updateSongHighlight() {
  if (!songMode) return;
  const area = document.getElementById('songArea');
  if (!area) return;

  // Remove current class from all tokens
  document.querySelectorAll('#songArea .token').forEach(el=>{
    el.classList.remove('current');
    el.classList.remove('done');
  });

  // Find next visible token (skip newline placeholders)
  let visIdx = songPos;
  while (visIdx < songTokens.length && songTokens[visIdx].text === '\n') visIdx++;
  if (visIdx < songTokens.length) {
    const el = document.querySelector(`#songArea .token[data-index="${visIdx}"]`);
    if (el) {
      el.classList.add('current');
      // Scroll to make current token visible
      requestAnimationFrame(scrollToCurrentToken);
    }
  }
  songTokens.forEach((t, idx) => {
    const tokenEl = document.querySelector(`#songArea .token[data-index="${idx}"]`);
    if (!tokenEl) return;
    
    // Mark completed tokens
    if (t.notes && t.notes.length > 0 && t.doneSteps >= t.notes.length) {
      tokenEl.classList.add('done');
    }
    
    // Update note hints if enabled
    if (showSongNotes) {
      const hintEl = tokenEl.querySelector('.hints');
      if (hintEl) {
        hintEl.textContent = t.notes && t.notes.length 
          ? t.notes.map(step => Array.isArray(step) ? step.join('') : step).join(' ')
          : '';
      }
    }
  });
  updateKeyboardGuideHighlight();
}

function handleNotePlayed(note) {
  if (!songTokens.length) return;
  // Skip non-note tokens
  while (songPos < songTokens.length && songTokens[songPos].notes.length === 0) songPos++;
  if (songPos >= songTokens.length) return;
  const cur = songTokens[songPos];
  const expected = cur.notes[cur.doneSteps];
  if (!expected) { songPos++; updateSongHighlight(); return; }
  if (Array.isArray(expected)) {
    // chord: require all expected notes
    if (expected.includes(note)) chordProgress.add(note);
    const allHit = expected.every(n => chordProgress.has(n));
    if (allHit) {
      chordProgress.clear();
      cur.doneSteps++;
      if (cur.doneSteps >= cur.notes.length) {
        songPos++;
        while (songPos < songTokens.length && songTokens[songPos].text === '\n') songPos++;
      }
      updateSongHighlight();
    }
  } else {
    if (note === expected) {
      cur.doneSteps++;
      if (cur.doneSteps >= cur.notes.length) {
        songPos++;
        while (songPos < songTokens.length && songTokens[songPos].text === '\n') songPos++;
      }
      updateSongHighlight();
    }
  }
}

function updateKeyboardGuideHighlight() {
  // Clear previous guide highlights
  document.querySelectorAll('.key.guide').forEach(el=> el.classList.remove('guide'));
  document.querySelectorAll('.key.guide-sharp').forEach(el=> el.classList.remove('guide-sharp'));
  document.querySelectorAll('.key.guide-shift').forEach(el=> el.classList.remove('guide-shift'));
  if (!songMode) return;
  if (!(highlightKeyboardGuide || spaceHeldGuide)) return;
  if (!songTokens.length) return;
  // Find next token needing a note
  let pos = songPos;
  while (pos < songTokens.length && songTokens[pos].notes.length === 0) pos++;
  if (pos >= songTokens.length) return;
  const cur = songTokens[pos];
  const expected = cur.notes[cur.doneSteps];
  if (!expected) return;
  const steps = Array.isArray(expected) ? expected : [expected];
  // Find keys that map to expected note for current instrument
  const currentMap = getCurrentMap();
  const topSharpKeys = new Set(['w','e','t','y','u','o','p']);
  for (const expectedNote of steps) {
    for (const [k, v] of Object.entries(currentMap)) {
      if (v === expectedNote) {
        const keyEl = document.querySelector(`[data-key="${CSS.escape(k)}"]`);
        if (keyEl) keyEl.classList.add('guide');
      } else if (topSharpKeys.has(k) && toSharpIfNeeded(v, true) === expectedNote) {
        const keyEl = document.querySelector(`[data-key="${CSS.escape(k)}"]`);
        if (keyEl) keyEl.classList.add('guide');
      }
    }
    // Also consider SHIFT-based sharp overrides (S,D,F and J,K,L)
    const pairs = [ ['s','F#3'], ['d','G#3'], ['f','A#3'], ['j','F#5'], ['k','G#5'], ['l','A#5'] ];
    for (const [k2, base] of pairs) {
      const n2 = transposeNote(base, transposeOctaves);
      if (n2 === expectedNote) {
        const keyEl2 = document.querySelector(`[data-key="${CSS.escape(k2)}"]`);
        if (keyEl2) keyEl2.classList.add('guide-shift');
      }
    }
  }
}

(async ()=>{
  // Draw staff immediately so it's visible on first paint
  try { renderComposerStaff(); } catch(_) {}
  await loadKeymap();
  await loadSamplesForInstrument(currentInstrument);
  console.log('Samples loaded for', currentInstrument);
  // Build keyboard UI on first load
  rebuildUI();
  // Initialize song mode UI (default hidden)
  updateSongModeUI();
})();

// Keep staff responsive
window.addEventListener('resize', ()=> { try { renderComposerStaff(); } catch(_) {} });

// Toggle staff visibility
document.getElementById('toggleStaff')?.addEventListener('change', (e)=>{
  const cst = document.getElementById('composerStaff');
  if (!cst) return;
  cst.style.display = e.target.checked ? '' : 'none';
  try { if (e.target.checked) renderComposerStaff(); } catch(_){}
});

// Safety: stop all sustained sounds on tab hide or window blur
window.addEventListener('blur', stopAll);
document.addEventListener('visibilitychange', ()=>{ if (document.hidden) stopAll(); });

document.getElementById('instrumentSelect').addEventListener('change', async (e)=>{
  currentInstrument = e.target.value;
  rebuildUI();
  if (currentInstrument !== 'piano') {
    await loadSamplesForInstrument(currentInstrument);
  }
  updateKeyboardGuideHighlight();
});

// Octave shift buttons
document.getElementById('octaveUpBtn').addEventListener('click', ()=>{
  transposeOctaves += 1;
  rebuildUI();
  updateKeyboardGuideHighlight();
});
document.getElementById('octaveDownBtn').addEventListener('click', ()=>{
  transposeOctaves -= 1;
  rebuildUI();
  updateKeyboardGuideHighlight();
});

// Prevent controls from stealing focus so keyboard is always playable
(()=>{
  const stop = ev => { ev.stopPropagation(); };
  const blurAfter = el => setTimeout(()=>{ try { el.blur(); } catch(_){} }, 0);
  const controls = Array.from(document.querySelectorAll('button, input, select, textarea'));
  controls.forEach(el => {
    // Don’t propagate key events from controls to global handlers
    ['keydown','keypress','keyup'].forEach(t => el.addEventListener(t, stop));
    // Blur on mouseup/change so focus returns to body
    if (el.tagName === 'SELECT') {
      // For selects, only blur after value actually changes to allow dropdown interaction
      el.addEventListener('change', ()=> blurAfter(el));
    } else {
      el.addEventListener('mouseup', ()=> blurAfter(el));
      el.addEventListener('change', ()=> blurAfter(el));
    }
    // Special case: selects need focus to open; just blur after interaction
    if (el.tagName !== 'SELECT') {
      el.addEventListener('focus', ()=> blurAfter(el));
    }
  });
})();

// Paste song handlers (modal)
function showPasteModal(show) {
  const el = document.getElementById('pasteModal');
  if (!el) return;
  el.style.display = show ? '' : 'none';
  if (show) setTimeout(()=>{ const ta = document.getElementById('songPasteModal'); if (ta) ta.focus(); }, 0);
}
document.getElementById('pasteSongBtn').addEventListener('click', ()=>{
  showPasteModal(true);
});
document.getElementById('pasteCancel').addEventListener('click', ()=>{
  showPasteModal(false);
});
document.getElementById('pasteApply').addEventListener('click', ()=>{
  const ta = document.getElementById('songPasteModal');
  const txt = (ta && ta.value || '').trim();
  if (!txt) { showPasteModal(false); return; }
  songTokens = parseSong(txt);
  songPos = 0;
  renderSong();
  updateSongHighlight();
  updateComposerStatus();
  showPasteModal(false);
});

window.addEventListener('keydown', (e)=>{
  // Ignore global keyboard handling when user is focused on form controls
  const ae = document.activeElement;
  if (ae && ['INPUT','TEXTAREA','SELECT','BUTTON'].includes(ae.tagName)) return;
  const k = e.key.toLowerCase();
  // Number keys to switch instrument (1..8 => piano..đàn bầu)
  {
    let digit = null;
    if (e.code && e.code.startsWith('Digit')) digit = e.code.slice(5);
    else if (e.code && e.code.startsWith('Numpad')) digit = e.code.slice(6);
    else if (/^[1-8]$/.test(k)) digit = k;
    if (digit && /^[1-8]$/.test(digit)) {
      const map = ['piano','guitar','tank-drum','sao','marimba','handpan','dan-da','dan-bau'];
      const idx = parseInt(digit,10) - 1;
      const sel = document.getElementById('instrumentSelect');
      if (sel && map[idx]) {
        sel.value = map[idx];
        sel.dispatchEvent(new Event('change', { bubbles:true }));
        // Blur after change so keyboard remains playable
        setTimeout(()=>{ try { sel.blur(); } catch(_){} }, 0);
      }
      e.preventDefault();
      return;
    }
  }
  // Composer navigation with arrow keys
  if (composerMode && (k === 'arrowleft' || k === 'arrowright')) {
    e.preventDefault();
    let idx = (composerSelectedIndex != null) ? composerSelectedIndex : (songPos || 0);
    const isWord = (t) => t && t.text !== '\n';
    if (k === 'arrowleft') {
      for (let j = idx - 1; j >= 0; j--) { if (isWord(songTokens[j])) { idx = j; break; } }
    } else {
      for (let j = idx + 1; j < songTokens.length; j++) { if (isWord(songTokens[j])) { idx = j; break; } }
    }
    if (idx !== composerSelectedIndex) {
      composerSelectedIndex = idx;
      updateComposerStatus();
      renderSong();
      const tokNow = songTokens[idx];
      if (tokNow && tokNow.notes && tokNow.notes.length) {
        try { ensureAudioContext(); } catch(_){ }
        tokNow.notes.forEach((nn, i2)=> setTimeout(()=>{ try { playNote(nn); } catch(_){ } }, i2 * 180));
      }
    }
    return;
  }
  // Toggle highlight with enter or backspace
  if (k === 'enter' || e.code === 'Enter' || k === 'backspace' || e.code === 'Backspace') {
    if (!spaceHeldGuide) {
      spaceHeldGuide = true;
      updateKeyboardGuideHighlight();
    }
    e.preventDefault();
    return;
  }
  // Handle spacebar as shift modifier for sharps
  if (k === ' ' || e.code === 'Space') {
    if (!spaceHeld) {
      spaceHeld = true;
      refreshLabelsForShift();
    }
    e.preventDefault();
    return;
  }
  if (k === 'shift') { if (!shiftHeld) { shiftHeld = true; refreshLabelsForShift(); } return; }
  if (k === 'control') { ctrlHeld = true; return; }
  if (pressedKeys.has(k)) return; // avoid repeats until keyup
  pressedKeys.add(k);
  const btn = document.querySelector(`[data-key="${CSS.escape(k)}"]`);
  if (btn) btn.classList.add('active');
  const currentMap = getCurrentMap();
  // Shift override takes precedence for specific keys
  const _bottomRow = new Set(['x','c','b','m',',']);
  let name = (e.shiftKey || shiftHeld || spaceHeld)
    ? (_bottomRow.has(k) ? currentMap[k] : (getShiftOverride(k) || currentMap[k]))
    : currentMap[k];
  // Do not auto-sharpify here; explicit sharps are encoded in maps/overrides
  name = toSharpIfNeeded(name, false);
  // If song guide expects the shift-sharp for this key, play that even without Shift
  const expected = getExpectedNextNote();
  const shiftName = (!_bottomRow.has(k) ? getShiftOverride(k) : null);
  const matchExpected = Array.isArray(expected) ? (expected && shiftName && expected.includes(shiftName)) : (expected && shiftName === expected);
  if (!e.shiftKey && !shiftHeld && !spaceHeld && matchExpected) name = shiftName;
  // Staff highlight
  if (name) {
    setStaffNoteActive(name, true);
    (window._staffNoteByKey = window._staffNoteByKey || {})[k] = name;
  }
  const inst = instruments[currentInstrument];
  const available = !!name && (inst.notes.length === 0 || inst.notes.includes(name));
  // Composer capture first (even if not playable)
  if (composerMode && composerSelectedIndex !== null && name) {
    const tok = songTokens[composerSelectedIndex];
    if (tok && tok.text !== '\n') {
      composerAddNote(tok, name, e.ctrlKey || ctrlHeld);
      renderSong();
    }
  }
  if (name && available) {
    ensureAudioContext();
    if (currentInstrument === 'piano' && window.tonePiano) {
      // Song guidance advances only in song mode
      if (songMode) handleNotePlayed(name);
      window.tonePiano.attack(name);
      // store mapping for release
      (window._pianoActiveByKey = window._pianoActiveByKey || {})[k] = name;
    } else if (currentInstrument === 'sao') {
      // Sáo sustain while key is held
      if (songMode) handleNotePlayed(name);
      const stop = startFluteSustain(name);
      (window._fluteActiveByKey = window._fluteActiveByKey || {})[k] = stop;
      if (btn) btn._fluteStop = stop;
    } else if (currentInstrument === 'dan-bau') {
      if (songMode) handleNotePlayed(name);
      const stop = startDanBauSustain(name);
      (window._danBauActiveByKey = window._danBauActiveByKey || {})[k] = stop;
      if (btn) btn._danBauStop = stop;
    } else {
      playNote(name);
    }
  }
});

window.addEventListener('keyup', (e)=>{
  const k = e.key.toLowerCase();
  // Handle enter or backspace key release
  if (k === 'enter' || e.code === 'Enter' || k === 'backspace' || e.code === 'Backspace') {
    if (spaceHeldGuide) {
      spaceHeldGuide = false;
      updateKeyboardGuideHighlight();
    }
    e.preventDefault();
    return;
  }
  if (k === 'shift') { shiftHeld = false; refreshLabelsForShift(); return; }
  if (k === ' ' || e.code === 'Space') { spaceHeld = false; refreshLabelsForShift(); return; }
  if (k === 'control') { ctrlHeld = false; return; }
  pressedKeys.delete(k);
  const btn = document.querySelector(`[data-key="${CSS.escape(k)}"]`);
  if (btn) btn.classList.remove('active');
  if (window._staffNoteByKey && window._staffNoteByKey[k]) {
    setStaffNoteActive(window._staffNoteByKey[k], false);
    delete window._staffNoteByKey[k];
  }
  if (currentInstrument === 'piano' && window.tonePiano && window._pianoActiveByKey && window._pianoActiveByKey[k]) {
    const note = window._pianoActiveByKey[k];
    window.tonePiano.release(note);
    delete window._pianoActiveByKey[k];
  } else if (currentInstrument === 'sao' && window._fluteActiveByKey && window._fluteActiveByKey[k]) {
    const stop = window._fluteActiveByKey[k];
    try { stop(); } catch(_){ }
    delete window._fluteActiveByKey[k];
  } else if (currentInstrument === 'sao' && btn && btn._fluteStop) {
    // Fallback in case the global map missed this key
    try { btn._fluteStop(); } catch(_){ }
    delete btn._fluteStop;
  } else if (currentInstrument === 'dan-bau' && window._danBauActiveByKey && window._danBauActiveByKey[k]) {
    const stop = window._danBauActiveByKey[k];
    try { stop(); } catch(_){ }
    delete window._danBauActiveByKey[k];
  } else if (currentInstrument === 'dan-bau' && btn && btn._danBauStop) {
    try { btn._danBauStop(); } catch(_){ }
    delete btn._danBauStop;
  }
});

// Song UI handlers
document.getElementById('loadSongBtn').addEventListener('click', async ()=>{
  const inp = document.getElementById('songFile');
  const file = inp.files && inp.files[0];
  if (!file) return;
  const txt = await file.text();
  songTokens = parseSong(txt);
  songPos = 0;
  renderSong();
  updateSongHighlight();
  // Remember opened filename for saving later
  openedSongFilename = file.name || '';
});

document.getElementById('resetSongBtn').addEventListener('click', ()=>{
  songTokens.forEach(t=> t.doneSteps = 0);
  songPos = 0;
  updateSongHighlight();
});

// Toggle handlers
document.getElementById('toggleShowNotes').addEventListener('change', (e)=>{
  showSongNotes = !!e.target.checked;
  renderSong();
  updateSongHighlight();
});
document.getElementById('toggleHighlightKeys').addEventListener('change', (e)=>{
  highlightKeyboardGuide = !!e.target.checked;
  updateKeyboardGuideHighlight();
});
document.getElementById('toggleSolfege').addEventListener('change', (e)=>{
  showSolfege = !!e.target.checked;
  refreshLabelsForShift();
});
document.getElementById('toggleSongMode').addEventListener('change', (e)=>{
  songMode = !!e.target.checked;
  updateSongModeUI();
});
document.getElementById('toggleComposer').addEventListener('change', (e)=>{
  composerMode = !!e.target.checked;
  if (!composerMode) composerSelectedIndex = null;
  updateComposerStatus();
  renderSong();
  updateSongModeUI();
});

function updateComposerStatus() {
  const el = document.getElementById('composerStatus');
  if (!el) return;
  if (!composerMode) { el.textContent = 'Soạn nhạc đang tắt'; return; }
  if (composerSelectedIndex === null) { el.textContent = 'Chọn một chữ để thêm nốt...'; return; }
  const tok = songTokens[composerSelectedIndex];
  if (!tok) { el.textContent = 'Không có chữ được chọn'; return; }
  const notes = (tok.notes && tok.notes.length) ? tok.notes.join(' ') : '(chưa có nốt)';
  el.textContent = `Đang chọn: "${tok.text}"  |  Nốt: ${notes}`;
}

document.getElementById('composerClearBtn').addEventListener('click', ()=>{
  if (!composerMode || composerSelectedIndex === null) return;
  const tok = songTokens[composerSelectedIndex];
  if (!tok || tok.text === '\n') return;
  tok.notes = [];
  renderSong();
  updateComposerStatus();
});

function serializeSongToTxt() {
  const parts = [];
  for (let i = 0; i < songTokens.length; i++) {
    const tok = songTokens[i];
    if (tok.text === '\n') { parts.push('\n'); continue; }
    const notes = (tok.notes || []).map(n=>`{${n}}`).join('');
    parts.push(tok.text + notes + ' ');
  }
  return parts.join('').replace(/[ ]+\n/g, '\n').trim();
}

document.getElementById('composerSaveBtn').addEventListener('click', ()=>{
  const txt = serializeSongToTxt();
  let filename = (openedSongFilename || '').trim();
  if (!filename) filename = 'bai-hat.txt';
  if (!/\.txt$/i.test(filename)) filename += '.txt';
  const blob = new Blob([txt], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});
</script>
<!-- Tone.js and piano layer -->
<script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
<script src="./tone.js"></script>
<script>
  const _svgNS = 'http://www.w3.org/2000/svg';
  function _csEl(tag, attrs){ const el = document.createElementNS(_svgNS, tag); for (const k in attrs) el.setAttribute(k, attrs[k]); return el; }
  function _csParse(name){ const m = String(name).trim().match(/^([A-G])(#|b)?(\d)$/i); if(!m) return null; return { l:m[1].toUpperCase(), a:m[2]||'', o:parseInt(m[3],10) }; }
  function _csNameToMidi(name){ const p=_csParse(name); if(!p) return null; const ord=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B']; let pc=p.l+(p.a||''); if(pc.endsWith('b')){ const fm={Db:'C#',Eb:'D#',Gb:'F#',Ab:'G#',Bb:'A#'}; pc=fm[pc]||pc; } const idx=ord.indexOf(pc); if(idx<0) return null; return (p.o+1)*12+idx; }
  function _csStep(name){ const map={C:0,D:1,E:2,F:3,G:4,A:5,B:6}; const p=_csParse(name); if(!p) return 0; return (p.o-4)*7 + (map[p.l]-map.E);
  }
  function _csDrawStaff(svg, width){ svg.innerHTML=''; const W=width,H=220; svg.setAttribute('viewBox',`0 0 ${W} ${H}`); const left=40,right=W-20,top=40,gap=14; for(let i=0;i<5;i++){ const y=top+i*gap; svg.appendChild(_csEl('line',{x1:left,y1:y,x2:right,y2:y, class:'staff-line'})); } svg.appendChild(_csEl('line',{x1:right-10,y1:top,x2:right-10,y2:top+4*gap, class:'barline'})); return {left,top,gap,right}; }
  function _csDrawNote(svg,x,name,m){ const step=_csStep(name); const yE4=m.top+4*m.gap; const y=yE4 - (m.gap/2)*step; const g=_csEl('g',{class:'note','data-name':String(name).toUpperCase()}); svg.appendChild(g); g.appendChild(_csEl('ellipse',{cx:x,cy:y,rx:10,ry:8,transform:`rotate(-20 ${x} ${y})`, class:'notehead'})); if (y>m.top+2*m.gap) g.appendChild(_csEl('line',{x1:x+9,y1:y,x2:x+9,y2:y-36,class:'staff-line'})); else g.appendChild(_csEl('line',{x1:x-9,y1:y,x2:x-9,y2:y+36,class:'staff-line'})); const low=m.top+4*m.gap, hi=m.top; if (y>low){ for(let yy=low+m.gap; yy<=y; yy+=m.gap){ g.appendChild(_csEl('line',{x1:x-14,y1:yy,x2:x+14,y2:yy,class:'ledger'})); } } if (y<hi){ for(let yy=hi-m.gap; yy>=y; yy-=m.gap){ g.appendChild(_csEl('line',{x1:x-14,y1:yy,x2:x+14,y2:yy,class:'ledger'})); } } const label=_csEl('text',{x:x+18,y:y+5,class:'note-label'}); label.textContent=String(name).toUpperCase(); g.appendChild(label);
    // Sustain behavior for sáo/đàn bầu on staff
    const startPlay = ()=>{
      ensureAudioContext();
      const nn = String(name).toUpperCase();
      // Composer capture first (like keyboard path)
      if (typeof composerMode !== 'undefined' && composerMode && composerSelectedIndex !== null) {
        const tok = (typeof songTokens !== 'undefined') ? songTokens[composerSelectedIndex] : null;
        if (tok && tok.text !== '\n') {
          tok.notes = tok.notes || [];
          tok.notes.push(nn);
          if (typeof renderSong === 'function') renderSong();
          if (typeof updateComposerStatus === 'function') updateComposerStatus();
        }
      }
      if (typeof currentInstrument !== 'undefined' && currentInstrument === 'sao') {
        g._stop = (typeof startFluteSustain === 'function') ? startFluteSustain(nn) : null;
      } else if (typeof currentInstrument !== 'undefined' && currentInstrument === 'dan-bau') {
        g._stop = (typeof startDanBauSustain === 'function') ? startDanBauSustain(nn) : null;
      } else {
        if (typeof playNote === 'function') playNote(nn);
      }
    };
    const stopPlay = ()=>{
      if (g._stop) { try { g._stop(); } catch(_){} g._stop = null; }
    };
    g.addEventListener('pointerdown', startPlay);
    g.addEventListener('pointerup', stopPlay);
    g.addEventListener('pointerleave', stopPlay);
    g.addEventListener('pointercancel', stopPlay);
  }
  function _csBuildFromC(o){ const o2=parseInt(o,10); return [`C${o2}`,`D${o2}`,`E${o2}`,`F${o2}`,`G${o2}`,`A${o2}`,`B${o2}`,`C${o2+1}`]; }
  function renderComposerStaff(){ const wrap=document.getElementById('composerStaff'); if (!wrap || wrap.style.display==='none') return; const svg=document.getElementById('composerStaffSvg'); let arr=[..._csBuildFromC(3),..._csBuildFromC(4),..._csBuildFromC(5)]; const seen=new Set(); arr=arr.filter(n=>{ const m=_csNameToMidi(n); if(m==null||seen.has(m)) return false; seen.add(m); return true; }).sort((a,b)=>(_csNameToMidi(a)||0)-(_csNameToMidi(b)||0)); const left=40; const startX=left+70; const spacing=52; const tail=90; const width = startX + spacing * Math.max(0, arr.length-1) + tail; const met=_csDrawStaff(svg, width); let x=startX; for(const n of arr){ _csDrawNote(svg,x,n,met); x+=spacing; }
  }
  // Draw once after function definition to ensure initial render
  try { renderComposerStaff(); } catch(_) {}
  // Helper: highlight note on staff
  function setStaffNoteActive(name, on) {
    const nn = String(name||'').toUpperCase();
    const el = document.querySelector(`.composer-staff .note[data-name="${CSS.escape(nn)}"]`);
    if (el) el.classList[on ? 'add' : 'remove']('active');
  }
  // Helper: expected next note in song mode (or null)
  function getExpectedNextNote() {
    if (!songMode || !Array.isArray(songTokens) || songTokens.length === 0) return null;
    let pos = songPos || 0;
    while (pos < songTokens.length) {
      const tok = songTokens[pos];
      const notes = tok && tok.notes || [];
      const done = tok && tok.doneSteps || 0;
      if (notes.length > 0 && done < notes.length) return notes[done];
      pos++;
    }
    return null;
  }
  // Helper: add note to token, combining with previous step if combine=true
  function composerAddNote(tok, note, combine) {
    tok.notes = tok.notes || [];
    if (combine && tok.notes.length > 0) {
      const lastIdx = tok.notes.length - 1;
      const last = tok.notes[lastIdx];
      if (Array.isArray(last)) {
        if (!last.includes(note)) last.push(note);
      } else {
        if (last !== note) tok.notes[lastIdx] = [last, note];
      }
      return;
    }
    tok.notes.push(note);
  }
</script>
</body>
</html>
