<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Guitar Test C4–C5 (Enhanced)</title>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
         background:#faf7f3; color:#222; margin:0; padding:24px;
         display:flex; flex-direction:column; align-items:center; }
  h1 { margin:0 0 16px; }
  .row { display:flex; gap:8px; flex-wrap:wrap; }
  .key { width:64px; height:64px; border-radius:10px; border:1px solid #ddd;
         background:#fff; display:flex; align-items:center; justify-content:center;
         cursor:pointer; box-shadow:0 6px 18px rgba(0,0,0,.06); user-select:none; }
  .key:active { transform: translateY(1px); box-shadow:none; }
</style>
</head>
<body>
<h1>Guitar Test C4–C5 (Mộc hơn)</h1>
<div class="row" id="keys"></div>

<script>
let audioCtx, reverb;
function ensureAudioContext(){
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    loadReverb();
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

// nạp impulse reverb (nhỏ gọn)
function loadReverb(){
  const url = "https://cdn.jsdelivr.net/gh/mdn/webaudio-examples/complex-sounds/impulse-responses/matrix-reverb2.wav";
  fetch(url)
    .then(r=>r.arrayBuffer())
    .then(b=>audioCtx.decodeAudioData(b))
    .then(buf=>{ reverb = audioCtx.createConvolver(); reverb.buffer = buf; });
}

function noteToFreq(name){
  const m = String(name).trim().match(/^([A-G])(#|b)?(\d)$/i); if(!m) return 440;
  const l = m[1].toUpperCase(); const a = m[2]||''; const o = parseInt(m[3],10);
  const map = {C:0, D:2, E:4, F:5, G:7, A:9, B:11}; let semi = map[l];
  if (a === '#') semi += 1; else if (a === 'b') semi -= 1;
  const midi = (o+1)*12 + semi; return 440 * Math.pow(2, (midi-69)/12);
}

// --- Guitar synthesis (Karplus–Strong, improved body + reverb) ---
function playGuitar(noteName){
  ensureAudioContext();
  const f = noteToFreq(noteName);
  const now = audioCtx.currentTime;
  const sr = audioCtx.sampleRate;
  const period = 1 / Math.max(40, Math.min(2000, f));

  // Noise burst (pick)
  const excLen = Math.max(1, Math.floor(sr * 0.012));
  const buf = audioCtx.createBuffer(1, excLen, sr);
  const ch = buf.getChannelData(0);
  for (let i=0;i<excLen;i++) ch[i] = (Math.random()*2-1)*(1 - i/excLen);
  const src = audioCtx.createBufferSource(); src.buffer = buf; src.loop = false;

  // pick position shaping
  const pickDelay = audioCtx.createDelay(0.01);
  pickDelay.delayTime.value = Math.min(0.008, period * 0.25);
  const inv = audioCtx.createGain(); inv.gain.value = -0.8;
  const pickMix = audioCtx.createGain(); pickMix.gain.value = 1.0;
  src.connect(pickMix);
  src.connect(pickDelay).connect(inv);
  inv.connect(pickMix);

  // Loop with damping filters
  const loopDelay = audioCtx.createDelay(1.0);
  loopDelay.delayTime.value = period;
  const fb = audioCtx.createGain();
  fb.gain.value = 0.5; // giảm sustain => mềm hơn
  const lpDamp = audioCtx.createBiquadFilter();
  lpDamp.type='lowpass'; lpDamp.frequency.value = 2000; lpDamp.Q.value = 0.3;
  const hpDamp = audioCtx.createBiquadFilter();
  hpDamp.type='highpass'; hpDamp.frequency.value = 60; hpDamp.Q.value = 0.7;

  loopDelay.connect(lpDamp).connect(hpDamp).connect(fb).connect(loopDelay);

  // Body resonance filters
  const body1 = audioCtx.createBiquadFilter();
  body1.type='bandpass'; body1.frequency.value = f*0.7; body1.Q.value = 1.5;
  const body2 = audioCtx.createBiquadFilter();
  body2.type='bandpass'; body2.frequency.value = f*1.1; body2.Q.value = 1.2;
  const body3 = audioCtx.createBiquadFilter();
  body3.type='bandpass'; body3.frequency.value = 220; body3.Q.value = 2.0;

  // Output tone
  const out = audioCtx.createGain();
  out.gain.setValueAtTime(0.0001, now);
  out.gain.exponentialRampToValueAtTime(0.9, now + 0.005);
  out.gain.exponentialRampToValueAtTime(0.0001, now + 2.8);

  const outLP = audioCtx.createBiquadFilter();
  outLP.type='lowpass'; outLP.frequency.value = 3200; outLP.Q.value = 0.7;

  const postGain = audioCtx.createGain();
  postGain.gain.value = 1.5;

  // Audio routing
  pickMix.connect(loopDelay);
  loopDelay.connect(body1).connect(body2).connect(body3).connect(out).connect(outLP);
  if (reverb) {
    const revMix = audioCtx.createGain(); revMix.gain.value = 0.3;
    outLP.connect(postGain);
    outLP.connect(revMix).connect(reverb).connect(audioCtx.destination);
    postGain.connect(audioCtx.destination);
  } else {
    outLP.connect(postGain).connect(audioCtx.destination);
  }

  src.start(now);
  src.stop(now + 0.02);
}

// Build keys C4..C5
const NOTES = ['C4','C#4','D4','D#4','E4','F4','F#4','G4','G#4','A4','A#4','B4','C5'];
const keysEl = document.getElementById('keys');
NOTES.forEach(n=>{
  const btn = document.createElement('div');
  btn.className = 'key';
  btn.textContent = n;
  btn.addEventListener('pointerdown', ()=>{ playGuitar(n); });
  keysEl.appendChild(btn);
});
</script>
</body>
</html>
